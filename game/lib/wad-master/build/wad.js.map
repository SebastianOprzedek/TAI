{"version":3,"sources":["webpack://Wad/webpack/universalModuleDefinition","webpack://Wad/webpack/bootstrap","webpack://Wad/./node_modules/tunajs/tuna.js","webpack://Wad/(webpack)/buildin/harmony-module.js","webpack://Wad/./src/wad.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK,QAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,6DAA6D;AAC7D;AACA,yDAAyD;AACzD;AACA,yDAAyD;AACzD;AACA,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uDAAuD;AACvD;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,+BAA+B,WAAW;AAC1C,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC5tED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,4BAA4B,mBAAmB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA,wCAAwC,+BAA+B;AACvE,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,+BAA+B;AAC3E,qDAAqD,iBAAiB;AACtE,uIAAuI;AACvI;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS,yBAAyB,2DAA2D,EAAE,EAAE;AACjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,0BAA0B;;AAEpE,0CAA0C,8BAA8B;;AAExE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oEAAoE;AACpE,2DAA2D;AAC3D;AACA,+BAA+B;AAC/B;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qCAAqC,2DAA2D;AAChG;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,yCAAyC;AACzC,6CAA6C,iCAAiC;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,8BAA8B,cAAc;AAC5C,+BAA+B,0BAA0B;AACzD,kBAAkB,kCAAkC;AACpD;AACA,iCAAiC,2DAA2D;AAC5F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,8BAA8B;;AAE9D;AACA;AACA;;;AAGA;;AAEA;;AAEA,sDAAsD,sBAAsB;AAC5E;;AAEA;AACA,iCAAiC,+BAA+B;;AAEhE;AACA,iCAAiC,+BAA+B;AAChE;AACA,6BAA6B,oBAAoB;AACjD;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,4BAA4B;AAC5B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;;AAEA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,qBAAqB,UAAU;AAC/B;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;;AAEA,sDAAsD;;AAEtD;AACA,4BAA4B,0BAA0B;;AAEtD,4BAA4B,8BAA8B;;AAE1D;;AAEA;AACA;AACA,+BAA+B,gCAAgC;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA,8DAA8D,qBAAqB;AACnF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,2CAA2C;AAC3C;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,uDAAuD;;AAEvD,SAAS;;AAET;AACA;AACA,2BAA2B,+BAA+B;AAC1D,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,kBAAkB;AAClB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,6CAA6C,oCAAoC;AACjF,gDAAgD,qCAAqC;AACrF;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA,6DAA6D;AAC7D;AACA,qCAAqC;AACrC,wBAAwB,2BAA2B;AACnD,sDAAsD;AACtD;AACA,kCAAkC;AAClC,0CAA0C;AAC1C,2EAA2E;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,uBAAuB,0BAA0B,sEAAsE,YAAY,4CAA4C,EAAE;AACjL,iBAAiB,0BAA0B,oEAAoE,YAAY,8CAA8C,EAAE;AAC3K,qBAAqB,0BAA0B,sEAAsE,YAAY,6CAA6C,EAAE;AAChL,iBAAiB,wCAAwC,qEAAqE,YAAY,kDAAkD,gCAAgC,EAAE,aAAa,yCAAyC,EAAE;AACtR,iBAAiB,yCAAyC,sEAAsE,YAAY,qDAAqD,+BAA+B,EAAE;AAClO;AACA;;AAEA,CAAC;;AAED;AACA;AACA;;AAEA","file":"wad.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Wad\"] = factory();\n\telse\n\t\troot[\"Wad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/wad.js\");\n","/*\r\n    Copyright (c) 2012 DinahMoe AB & Oskar Eriksson\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\r\n    files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\r\n    modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\r\n    is furnished to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n/*global module*/\r\n(function() {\r\n\r\n    var userContext,\r\n        userInstance,\r\n        pipe = function(param, val) {\r\n            param.value = val;\r\n        },\r\n        Super = Object.create(null, {\r\n            activate: {\r\n                writable: true,\r\n                value: function(doActivate) {\r\n                    if (doActivate) {\r\n                        this.input.disconnect();\r\n                        this.input.connect(this.activateNode);\r\n                        if (this.activateCallback) {\r\n                            this.activateCallback(doActivate);\r\n                        }\r\n                    } else {\r\n                        this.input.disconnect();\r\n                        this.input.connect(this.output);\r\n                    }\r\n                }\r\n            },\r\n            bypass: {\r\n                get: function() {\r\n                    return this._bypass;\r\n                },\r\n                set: function(value) {\r\n                    if (this._lastBypassValue === value) {\r\n                        return;\r\n                    }\r\n                    this._bypass = value;\r\n                    this.activate(!value);\r\n                    this._lastBypassValue = value;\r\n                }\r\n            },\r\n            connect: {\r\n                value: function(target) {\r\n                    this.output.connect(target);\r\n                }\r\n            },\r\n            disconnect: {\r\n                value: function(target) {\r\n                    this.output.disconnect(target);\r\n                }\r\n            },\r\n            connectInOrder: {\r\n                value: function(nodeArray) {\r\n                    var i = nodeArray.length - 1;\r\n                    while (i--) {\r\n                        if (!nodeArray[i].connect) {\r\n                            return console.error(\"AudioNode.connectInOrder: TypeError: Not an AudioNode.\", nodeArray[i]);\r\n                        }\r\n                        if (nodeArray[i + 1].input) {\r\n                            nodeArray[i].connect(nodeArray[i + 1].input);\r\n                        } else {\r\n                            nodeArray[i].connect(nodeArray[i + 1]);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            getDefaults: {\r\n                value: function() {\r\n                    var result = {};\r\n                    for (var key in this.defaults) {\r\n                        result[key] = this.defaults[key].value;\r\n                    }\r\n                    return result;\r\n                }\r\n            },\r\n            automate: {\r\n                value: function(property, value, duration, startTime) {\r\n                    var start = startTime ? ~~(startTime / 1000) : userContext.currentTime,\r\n                        dur = duration ? ~~(duration / 1000) : 0,\r\n                        _is = this.defaults[property],\r\n                        param = this[property],\r\n                        method;\r\n\r\n                    if (param) {\r\n                        if (_is.automatable) {\r\n                            if (!duration) {\r\n                                method = \"setValueAtTime\";\r\n                            } else {\r\n                                method = \"linearRampToValueAtTime\";\r\n                                param.cancelScheduledValues(start);\r\n                                param.setValueAtTime(param.value, start);\r\n                            }\r\n                            param[method](value, dur + start);\r\n                        } else {\r\n                            param = value;\r\n                        }\r\n                    } else {\r\n                        console.error(\"Invalid Property for \" + this.name);\r\n                    }\r\n                }\r\n            }\r\n        }),\r\n        FLOAT = \"float\",\r\n        BOOLEAN = \"boolean\",\r\n        STRING = \"string\",\r\n        INT = \"int\";\r\n\r\n    if (typeof module !== \"undefined\" && module.exports) {\r\n        module.exports = Tuna;\r\n    } else if (typeof define === \"function\") {\r\n        window.define(\"Tuna\", definition);\r\n    } else {\r\n        window.Tuna = Tuna;\r\n    }\r\n\r\n    function definition() {\r\n        return Tuna;\r\n    }\r\n\r\n    function Tuna(context) {\r\n        if (!(this instanceof Tuna)) {\r\n            return new Tuna(context);\r\n        }\r\n\r\n        var _window = typeof window === \"undefined\" ? {} : window;\r\n\r\n        if (!_window.AudioContext) {\r\n            _window.AudioContext = _window.webkitAudioContext;\r\n        }\r\n        if (!context) {\r\n            console.log(\"tuna.js: Missing audio context! Creating a new context for you.\");\r\n            context = _window.AudioContext && (new _window.AudioContext());\r\n        }\r\n        if (!context) {\r\n            throw new Error(\"Tuna cannot initialize because this environment does not support web audio.\");\r\n        }\r\n        connectify(context);\r\n        userContext = context;\r\n        userInstance = this;\r\n    }\r\n\r\n    function connectify(context) {\r\n        if (context.__connectified__ === true) return;\r\n\r\n        var gain = context.createGain(),\r\n            proto = Object.getPrototypeOf(Object.getPrototypeOf(gain)),\r\n            oconnect = proto.connect;\r\n\r\n        proto.connect = shimConnect;\r\n        context.__connectified__ = true; // Prevent overriding connect more than once\r\n\r\n        function shimConnect() {\r\n            var node = arguments[0];\r\n            arguments[0] = Super.isPrototypeOf ? (Super.isPrototypeOf(node) ? node.input : node) : (node.input || node);\r\n            oconnect.apply(this, arguments);\r\n            return node;\r\n        }\r\n    }\r\n\r\n    function dbToWAVolume(db) {\r\n        return Math.max(0, Math.round(100 * Math.pow(2, db / 6)) / 100);\r\n    }\r\n\r\n    function fmod(x, y) {\r\n        // http://kevin.vanzonneveld.net\r\n        // *     example 1: fmod(5.7, 1.3);\r\n        // *     returns 1: 0.5\r\n        var tmp, tmp2, p = 0,\r\n            pY = 0,\r\n            l = 0.0,\r\n            l2 = 0.0;\r\n\r\n        tmp = x.toExponential().match(/^.\\.?(.*)e(.+)$/);\r\n        p = parseInt(tmp[2], 10) - (tmp[1] + \"\").length;\r\n        tmp = y.toExponential().match(/^.\\.?(.*)e(.+)$/);\r\n        pY = parseInt(tmp[2], 10) - (tmp[1] + \"\").length;\r\n\r\n        if (pY > p) {\r\n            p = pY;\r\n        }\r\n\r\n        tmp2 = (x % y);\r\n\r\n        if (p < -100 || p > 20) {\r\n            // toFixed will give an out of bound error so we fix it like this:\r\n            l = Math.round(Math.log(tmp2) / Math.log(10));\r\n            l2 = Math.pow(10, l);\r\n\r\n            return (tmp2 / l2).toFixed(l - p) * l2;\r\n        } else {\r\n            return parseFloat(tmp2.toFixed(-p));\r\n        }\r\n    }\r\n\r\n    function sign(x) {\r\n        if (x === 0) {\r\n            return 1;\r\n        } else {\r\n            return Math.abs(x) / x;\r\n        }\r\n    }\r\n\r\n    function tanh(n) {\r\n        return (Math.exp(n) - Math.exp(-n)) / (Math.exp(n) + Math.exp(-n));\r\n    }\r\n\r\n    function initValue(userVal, defaultVal) {\r\n        return userVal === undefined ? defaultVal : userVal;\r\n    }\r\n\r\n    Tuna.prototype.Bitcrusher = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.bufferSize = properties.bufferSize || this.defaults.bufferSize.value;\r\n\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.processor = userContext.createScriptProcessor(this.bufferSize, 1, 1);\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.processor);\r\n        this.processor.connect(this.output);\r\n\r\n        var phaser = 0,\r\n            last = 0,\r\n            input, output, step, i, length;\r\n        this.processor.onaudioprocess = function(e) {\r\n            input = e.inputBuffer.getChannelData(0),\r\n            output = e.outputBuffer.getChannelData(0),\r\n            step = Math.pow(1 / 2, this.bits);\r\n            length = input.length;\r\n            for (i = 0; i < length; i++) {\r\n                phaser += this.normfreq;\r\n                if (phaser >= 1.0) {\r\n                    phaser -= 1.0;\r\n                    last = step * Math.floor(input[i] / step + 0.5);\r\n                }\r\n                output[i] = last;\r\n            }\r\n        };\r\n\r\n        this.bits = properties.bits || this.defaults.bits.value;\r\n        this.normfreq = initValue(properties.normfreq, this.defaults.normfreq.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Bitcrusher.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Bitcrusher\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                bits: {\r\n                    value: 4,\r\n                    min: 1,\r\n                    max: 16,\r\n                    automatable: false,\r\n                    type: INT\r\n                },\r\n                bufferSize: {\r\n                    value: 4096,\r\n                    min: 256,\r\n                    max: 16384,\r\n                    automatable: false,\r\n                    type: INT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                normfreq: {\r\n                    value: 0.1,\r\n                    min: 0.0001,\r\n                    max: 1.0,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                }\r\n            }\r\n        },\r\n        bits: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.processor.bits;\r\n            },\r\n            set: function(value) {\r\n                this.processor.bits = value;\r\n            }\r\n        },\r\n        normfreq: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.processor.normfreq;\r\n            },\r\n            set: function(value) {\r\n                this.processor.normfreq = value;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Cabinet = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.convolver = this.newConvolver(properties.impulsePath || \"../impulses/impulse_guitar.wav\");\r\n        this.makeupNode = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.convolver.input);\r\n        this.convolver.output.connect(this.makeupNode);\r\n        this.makeupNode.connect(this.output);\r\n\r\n        this.makeupGain = initValue(properties.makeupGain, this.defaults.makeupGain.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Cabinet.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Cabinet\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                makeupGain: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 20,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        makeupGain: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.makeupNode.gain;\r\n            },\r\n            set: function(value) {\r\n                this.makeupNode.gain.value = value;\r\n            }\r\n        },\r\n        newConvolver: {\r\n            value: function(impulsePath) {\r\n                return new userInstance.Convolver({\r\n                    impulse: impulsePath,\r\n                    dryLevel: 0,\r\n                    wetLevel: 1\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Chorus = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.attenuator = this.activateNode = userContext.createGain();\r\n        this.splitter = userContext.createChannelSplitter(2);\r\n        this.delayL = userContext.createDelay();\r\n        this.delayR = userContext.createDelay();\r\n        this.feedbackGainNodeLR = userContext.createGain();\r\n        this.feedbackGainNodeRL = userContext.createGain();\r\n        this.merger = userContext.createChannelMerger(2);\r\n        this.output = userContext.createGain();\r\n\r\n        this.lfoL = new userInstance.LFO({\r\n            target: this.delayL.delayTime,\r\n            callback: pipe\r\n        });\r\n        this.lfoR = new userInstance.LFO({\r\n            target: this.delayR.delayTime,\r\n            callback: pipe\r\n        });\r\n\r\n        this.input.connect(this.attenuator);\r\n        this.attenuator.connect(this.output);\r\n        this.attenuator.connect(this.splitter);\r\n        this.splitter.connect(this.delayL, 0);\r\n        this.splitter.connect(this.delayR, 1);\r\n        this.delayL.connect(this.feedbackGainNodeLR);\r\n        this.delayR.connect(this.feedbackGainNodeRL);\r\n        this.feedbackGainNodeLR.connect(this.delayR);\r\n        this.feedbackGainNodeRL.connect(this.delayL);\r\n        this.delayL.connect(this.merger, 0, 0);\r\n        this.delayR.connect(this.merger, 0, 1);\r\n        this.merger.connect(this.output);\r\n\r\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\r\n        this.rate = initValue(properties.rate, this.defaults.rate.value);\r\n        this.delay = initValue(properties.delay, this.defaults.delay.value);\r\n        this.depth = initValue(properties.depth, this.defaults.depth.value);\r\n        this.lfoR.phase = Math.PI / 2;\r\n        this.attenuator.gain.value = 0.6934; // 1 / (10 ^ (((20 * log10(3)) / 3) / 20))\r\n        this.lfoL.activate(true);\r\n        this.lfoR.activate(true);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Chorus.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Chorus\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                feedback: {\r\n                    value: 0.4,\r\n                    min: 0,\r\n                    max: 0.95,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                delay: {\r\n                    value: 0.0045,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                depth: {\r\n                    value: 0.7,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                rate: {\r\n                    value: 1.5,\r\n                    min: 0,\r\n                    max: 8,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        delay: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._delay;\r\n            },\r\n            set: function(value) {\r\n                this._delay = 0.0002 * (Math.pow(10, value) * 2);\r\n                this.lfoL.offset = this._delay;\r\n                this.lfoR.offset = this._delay;\r\n                this._depth = this._depth;\r\n            }\r\n        },\r\n        depth: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._depth;\r\n            },\r\n            set: function(value) {\r\n                this._depth = value;\r\n                this.lfoL.oscillation = this._depth * this._delay;\r\n                this.lfoR.oscillation = this._depth * this._delay;\r\n            }\r\n        },\r\n        feedback: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._feedback;\r\n            },\r\n            set: function(value) {\r\n                this._feedback = value;\r\n                this.feedbackGainNodeLR.gain.value = this._feedback;\r\n                this.feedbackGainNodeRL.gain.value = this._feedback;\r\n            }\r\n        },\r\n        rate: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._rate;\r\n            },\r\n            set: function(value) {\r\n                this._rate = value;\r\n                this.lfoL.frequency = this._rate;\r\n                this.lfoR.frequency = this._rate;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Compressor = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.compNode = this.activateNode = userContext.createDynamicsCompressor();\r\n        this.makeupNode = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n\r\n        this.compNode.connect(this.makeupNode);\r\n        this.makeupNode.connect(this.output);\r\n\r\n        this.automakeup = initValue(properties.automakeup, this.defaults.automakeup.value);\r\n        this.makeupGain = initValue(properties.makeupGain, this.defaults.makeupGain.value);\r\n        this.threshold = initValue(properties.threshold, this.defaults.threshold.value);\r\n        this.release = initValue(properties.release, this.defaults.release.value);\r\n        this.attack = initValue(properties.attack, this.defaults.attack.value);\r\n        this.ratio = properties.ratio || this.defaults.ratio.value;\r\n        this.knee = initValue(properties.knee, this.defaults.knee.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Compressor.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Compressor\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                threshold: {\r\n                    value: -20,\r\n                    min: -60,\r\n                    max: 0,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                release: {\r\n                    value: 250,\r\n                    min: 10,\r\n                    max: 2000,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                makeupGain: {\r\n                    value: 1,\r\n                    min: 1,\r\n                    max: 100,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                attack: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1000,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                ratio: {\r\n                    value: 4,\r\n                    min: 1,\r\n                    max: 50,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                knee: {\r\n                    value: 5,\r\n                    min: 0,\r\n                    max: 40,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                automakeup: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        computeMakeup: {\r\n            value: function() {\r\n                var magicCoefficient = 4, // raise me if the output is too hot\r\n                    c = this.compNode;\r\n                return -(c.threshold.value - c.threshold.value / c.ratio.value) / magicCoefficient;\r\n            }\r\n        },\r\n        automakeup: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._automakeup;\r\n            },\r\n            set: function(value) {\r\n                this._automakeup = value;\r\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\r\n            }\r\n        },\r\n        threshold: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.compNode.threshold;\r\n            },\r\n            set: function(value) {\r\n                this.compNode.threshold.value = value;\r\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\r\n            }\r\n        },\r\n        ratio: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.compNode.ratio;\r\n            },\r\n            set: function(value) {\r\n                this.compNode.ratio.value = value;\r\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\r\n            }\r\n        },\r\n        knee: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.compNode.knee;\r\n            },\r\n            set: function(value) {\r\n                this.compNode.knee.value = value;\r\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\r\n            }\r\n        },\r\n        attack: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.compNode.attack;\r\n            },\r\n            set: function(value) {\r\n                this.compNode.attack.value = value / 1000;\r\n            }\r\n        },\r\n        release: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.compNode.release;\r\n            },\r\n            set: function(value) {\r\n                this.compNode.release.value = value / 1000;\r\n            }\r\n        },\r\n        makeupGain: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.makeupNode.gain;\r\n            },\r\n            set: function(value) {\r\n                this.makeupNode.gain.value = dbToWAVolume(value);\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Convolver = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.convolver = userContext.createConvolver();\r\n        this.dry = userContext.createGain();\r\n        this.filterLow = userContext.createBiquadFilter();\r\n        this.filterHigh = userContext.createBiquadFilter();\r\n        this.wet = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.filterLow);\r\n        this.activateNode.connect(this.dry);\r\n        this.filterLow.connect(this.filterHigh);\r\n        this.filterHigh.connect(this.convolver);\r\n        this.convolver.connect(this.wet);\r\n        this.wet.connect(this.output);\r\n        this.dry.connect(this.output);\r\n\r\n        this.dryLevel = initValue(properties.dryLevel, this.defaults.dryLevel.value);\r\n        this.wetLevel = initValue(properties.wetLevel, this.defaults.wetLevel.value);\r\n        this.highCut = properties.highCut || this.defaults.highCut.value;\r\n        this.buffer = properties.impulse || \"../impulses/ir_rev_short.wav\";\r\n        this.lowCut = properties.lowCut || this.defaults.lowCut.value;\r\n        this.level = initValue(properties.level, this.defaults.level.value);\r\n        this.filterHigh.type = \"lowpass\";\r\n        this.filterLow.type = \"highpass\";\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Convolver.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Convolver\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                highCut: {\r\n                    value: 22050,\r\n                    min: 20,\r\n                    max: 22050,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                lowCut: {\r\n                    value: 20,\r\n                    min: 20,\r\n                    max: 22050,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                dryLevel: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                wetLevel: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                level: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        lowCut: {\r\n            get: function() {\r\n                return this.filterLow.frequency;\r\n            },\r\n            set: function(value) {\r\n                this.filterLow.frequency.value = value;\r\n            }\r\n        },\r\n        highCut: {\r\n            get: function() {\r\n                return this.filterHigh.frequency;\r\n            },\r\n            set: function(value) {\r\n                this.filterHigh.frequency.value = value;\r\n            }\r\n        },\r\n        level: {\r\n            get: function() {\r\n                return this.output.gain;\r\n            },\r\n            set: function(value) {\r\n                this.output.gain.value = value;\r\n            }\r\n        },\r\n        dryLevel: {\r\n            get: function() {\r\n                return this.dry.gain;\r\n            },\r\n            set: function(value) {\r\n                this.dry.gain.value = value;\r\n            }\r\n        },\r\n        wetLevel: {\r\n            get: function() {\r\n                return this.wet.gain;\r\n            },\r\n            set: function(value) {\r\n                this.wet.gain.value = value;\r\n            }\r\n        },\r\n        buffer: {\r\n            enumerable: false,\r\n            get: function() {\r\n                return this.convolver.buffer;\r\n            },\r\n            set: function(impulse) {\r\n                var convolver = this.convolver,\r\n                    xhr = new XMLHttpRequest();\r\n                if (!impulse) {\r\n                    console.log(\"Tuna.Convolver.setBuffer: Missing impulse path!\");\r\n                    return;\r\n                }\r\n                xhr.open(\"GET\", impulse, true);\r\n                xhr.responseType = \"arraybuffer\";\r\n                xhr.onreadystatechange = function() {\r\n                    if (xhr.readyState === 4) {\r\n                        if (xhr.status < 300 && xhr.status > 199 || xhr.status === 302) {\r\n                            userContext.decodeAudioData(xhr.response, function(buffer) {\r\n                                convolver.buffer = buffer;\r\n                            }, function(e) {\r\n                                if (e) console.log(\"Tuna.Convolver.setBuffer: Error decoding data\" + e);\r\n                            });\r\n                        }\r\n                    }\r\n                };\r\n                xhr.send(null);\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Delay = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.dry = userContext.createGain();\r\n        this.wet = userContext.createGain();\r\n        this.filter = userContext.createBiquadFilter();\r\n        this.delay = userContext.createDelay(10);\r\n        this.feedbackNode = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.delay);\r\n        this.activateNode.connect(this.dry);\r\n        this.delay.connect(this.filter);\r\n        this.filter.connect(this.feedbackNode);\r\n        this.feedbackNode.connect(this.delay);\r\n        this.feedbackNode.connect(this.wet);\r\n        this.wet.connect(this.output);\r\n        this.dry.connect(this.output);\r\n\r\n        this.delayTime = properties.delayTime || this.defaults.delayTime.value;\r\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\r\n        this.wetLevel = initValue(properties.wetLevel, this.defaults.wetLevel.value);\r\n        this.dryLevel = initValue(properties.dryLevel, this.defaults.dryLevel.value);\r\n        this.cutoff = properties.cutoff || this.defaults.cutoff.value;\r\n        this.filter.type = \"lowpass\";\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Delay.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Delay\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                delayTime: {\r\n                    value: 100,\r\n                    min: 20,\r\n                    max: 1000,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                feedback: {\r\n                    value: 0.45,\r\n                    min: 0,\r\n                    max: 0.9,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                cutoff: {\r\n                    value: 20000,\r\n                    min: 20,\r\n                    max: 20000,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                wetLevel: {\r\n                    value: 0.5,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                dryLevel: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        delayTime: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.delay.delayTime;\r\n            },\r\n            set: function(value) {\r\n                this.delay.delayTime.value = value / 1000;\r\n            }\r\n        },\r\n        wetLevel: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.wet.gain;\r\n            },\r\n            set: function(value) {\r\n                this.wet.gain.value = value;\r\n            }\r\n        },\r\n        dryLevel: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.dry.gain;\r\n            },\r\n            set: function(value) {\r\n                this.dry.gain.value = value;\r\n            }\r\n        },\r\n        feedback: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.feedbackNode.gain;\r\n            },\r\n            set: function(value) {\r\n                this.feedbackNode.gain.value = value;\r\n            }\r\n        },\r\n        cutoff: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.filter.frequency;\r\n            },\r\n            set: function(value) {\r\n                this.filter.frequency.value = value;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Filter = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.filter = userContext.createBiquadFilter();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.filter);\r\n        this.filter.connect(this.output);\r\n\r\n        this.frequency = properties.frequency || this.defaults.frequency.value;\r\n        this.Q = properties.resonance || this.defaults.Q.value;\r\n        this.filterType = initValue(properties.filterType, this.defaults.filterType.value);\r\n        this.gain = initValue(properties.gain, this.defaults.gain.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Filter.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Filter\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                frequency: {\r\n                    value: 800,\r\n                    min: 20,\r\n                    max: 22050,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                Q: {\r\n                    value: 1,\r\n                    min: 0.001,\r\n                    max: 100,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                gain: {\r\n                    value: 0,\r\n                    min: -40,\r\n                    max: 40,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                filterType: {\r\n                    value: \"lowpass\",\r\n                    automatable: false,\r\n                    type: STRING\r\n                }\r\n            }\r\n        },\r\n        filterType: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.filter.type;\r\n            },\r\n            set: function(value) {\r\n                this.filter.type = value;\r\n            }\r\n        },\r\n        Q: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.filter.Q;\r\n            },\r\n            set: function(value) {\r\n                this.filter.Q.value = value;\r\n            }\r\n        },\r\n        gain: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.filter.gain;\r\n            },\r\n            set: function(value) {\r\n                this.filter.gain.value = value;\r\n            }\r\n        },\r\n        frequency: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.filter.frequency;\r\n            },\r\n            set: function(value) {\r\n                this.filter.frequency.value = value;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Gain = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.gainNode = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.gainNode);\r\n        this.gainNode.connect(this.output);\r\n\r\n        this.gain = initValue(properties.gain, this.defaults.gain.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Gain.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Gain\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                gain: {\r\n                    value: 1.0,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                }\r\n            }\r\n        },\r\n        gain: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.gainNode.gain;\r\n            },\r\n            set: function(value) {\r\n                this.gainNode.gain.value = value;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.MoogFilter = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.bufferSize = properties.bufferSize || this.defaults.bufferSize.value;\r\n\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.processor = userContext.createScriptProcessor(this.bufferSize, 1, 1);\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.processor);\r\n        this.processor.connect(this.output);\r\n\r\n        var in1, in2, in3, in4, out1, out2, out3, out4;\r\n        in1 = in2 = in3 = in4 = out1 = out2 = out3 = out4 = 0.0;\r\n        var input, output, f, fb, i, length, inputFactor;\r\n        this.processor.onaudioprocess = function(e) {\r\n            input = e.inputBuffer.getChannelData(0),\r\n                output = e.outputBuffer.getChannelData(0),\r\n                f = this.cutoff * 1.16,\r\n                inputFactor = 0.35013 * (f * f) * (f * f);\r\n            fb = this.resonance * (1.0 - 0.15 * f * f);\r\n            length = input.length;\r\n            for (i = 0; i < length; i++) {\r\n                input[i] -= out4 * fb;\r\n                input[i] *= inputFactor;\r\n                out1 = input[i] + 0.3 * in1 + (1 - f) * out1; // Pole 1\r\n                in1 = input[i];\r\n                out2 = out1 + 0.3 * in2 + (1 - f) * out2; // Pole 2\r\n                in2 = out1;\r\n                out3 = out2 + 0.3 * in3 + (1 - f) * out3; // Pole 3\r\n                in3 = out2;\r\n                out4 = out3 + 0.3 * in4 + (1 - f) * out4; // Pole 4\r\n                in4 = out3;\r\n                output[i] = out4;\r\n            }\r\n        };\r\n\r\n        this.cutoff = initValue(properties.cutoff, this.defaults.cutoff.value);\r\n        this.resonance = initValue(properties.resonance, this.defaults.resonance.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.MoogFilter.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"MoogFilter\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                bufferSize: {\r\n                    value: 4096,\r\n                    min: 256,\r\n                    max: 16384,\r\n                    automatable: false,\r\n                    type: INT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                cutoff: {\r\n                    value: 0.065,\r\n                    min: 0.0001,\r\n                    max: 1.0,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                resonance: {\r\n                    value: 3.5,\r\n                    min: 0.0,\r\n                    max: 4.0,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                }\r\n            }\r\n        },\r\n        cutoff: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.processor.cutoff;\r\n            },\r\n            set: function(value) {\r\n                this.processor.cutoff = value;\r\n            }\r\n        },\r\n        resonance: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.processor.resonance;\r\n            },\r\n            set: function(value) {\r\n                this.processor.resonance = value;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Overdrive = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.inputDrive = userContext.createGain();\r\n        this.waveshaper = userContext.createWaveShaper();\r\n        this.outputDrive = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.inputDrive);\r\n        this.inputDrive.connect(this.waveshaper);\r\n        this.waveshaper.connect(this.outputDrive);\r\n        this.outputDrive.connect(this.output);\r\n\r\n        this.ws_table = new Float32Array(this.k_nSamples);\r\n        this.drive = initValue(properties.drive, this.defaults.drive.value);\r\n        this.outputGain = initValue(properties.outputGain, this.defaults.outputGain.value);\r\n        this.curveAmount = initValue(properties.curveAmount, this.defaults.curveAmount.value);\r\n        this.algorithmIndex = initValue(properties.algorithmIndex, this.defaults.algorithmIndex.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Overdrive.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Overdrive\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                drive: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT,\r\n                    scaled: true\r\n                },\r\n                outputGain: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: true,\r\n                    type: FLOAT,\r\n                    scaled: true\r\n                },\r\n                curveAmount: {\r\n                    value: 0.725,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                algorithmIndex: {\r\n                    value: 0,\r\n                    min: 0,\r\n                    max: 5,\r\n                    automatable: false,\r\n                    type: INT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        k_nSamples: {\r\n            value: 8192\r\n        },\r\n        drive: {\r\n            get: function() {\r\n                return this.inputDrive.gain;\r\n            },\r\n            set: function(value) {\r\n                this._drive = value;\r\n            }\r\n        },\r\n        curveAmount: {\r\n            get: function() {\r\n                return this._curveAmount;\r\n            },\r\n            set: function(value) {\r\n                this._curveAmount = value;\r\n                if (this._algorithmIndex === undefined) {\r\n                    this._algorithmIndex = 0;\r\n                }\r\n                this.waveshaperAlgorithms[this._algorithmIndex](this._curveAmount, this.k_nSamples, this.ws_table);\r\n                this.waveshaper.curve = this.ws_table;\r\n            }\r\n        },\r\n        outputGain: {\r\n            get: function() {\r\n                return this.outputDrive.gain;\r\n            },\r\n            set: function(value) {\r\n                this._outputGain = dbToWAVolume(value);\r\n            }\r\n        },\r\n        algorithmIndex: {\r\n            get: function() {\r\n                return this._algorithmIndex;\r\n            },\r\n            set: function(value) {\r\n                this._algorithmIndex = value;\r\n                this.curveAmount = this._curveAmount;\r\n            }\r\n        },\r\n        waveshaperAlgorithms: {\r\n            value: [\r\n                function(amount, n_samples, ws_table) {\r\n                    amount = Math.min(amount, 0.9999);\r\n                    var k = 2 * amount / (1 - amount),\r\n                        i, x;\r\n                    for (i = 0; i < n_samples; i++) {\r\n                        x = i * 2 / n_samples - 1;\r\n                        ws_table[i] = (1 + k) * x / (1 + k * Math.abs(x));\r\n                    }\r\n                },\r\n                function(amount, n_samples, ws_table) {\r\n                    var i, x, y;\r\n                    for (i = 0; i < n_samples; i++) {\r\n                        x = i * 2 / n_samples - 1;\r\n                        y = ((0.5 * Math.pow((x + 1.4), 2)) - 1) * y >= 0 ? 5.8 : 1.2;\r\n                        ws_table[i] = tanh(y);\r\n                    }\r\n                },\r\n                function(amount, n_samples, ws_table) {\r\n                    var i, x, y, a = 1 - amount;\r\n                    for (i = 0; i < n_samples; i++) {\r\n                        x = i * 2 / n_samples - 1;\r\n                        y = x < 0 ? -Math.pow(Math.abs(x), a + 0.04) : Math.pow(x, a);\r\n                        ws_table[i] = tanh(y * 2);\r\n                    }\r\n                },\r\n                function(amount, n_samples, ws_table) {\r\n                    var i, x, y, abx, a = 1 - amount > 0.99 ? 0.99 : 1 - amount;\r\n                    for (i = 0; i < n_samples; i++) {\r\n                        x = i * 2 / n_samples - 1;\r\n                        abx = Math.abs(x);\r\n                        if (abx < a) y = abx;\r\n                        else if (abx > a) y = a + (abx - a) / (1 + Math.pow((abx - a) / (1 - a), 2));\r\n                        else if (abx > 1) y = abx;\r\n                        ws_table[i] = sign(x) * y * (1 / ((a + 1) / 2));\r\n                    }\r\n                },\r\n                function(amount, n_samples, ws_table) { // fixed curve, amount doesn't do anything, the distortion is just from the drive\r\n                    var i, x;\r\n                    for (i = 0; i < n_samples; i++) {\r\n                        x = i * 2 / n_samples - 1;\r\n                        if (x < -0.08905) {\r\n                            ws_table[i] = (-3 / 4) * (1 - (Math.pow((1 - (Math.abs(x) - 0.032857)), 12)) + (1 / 3) * (Math.abs(x) - 0.032847)) + 0.01;\r\n                        } else if (x >= -0.08905 && x < 0.320018) {\r\n                            ws_table[i] = (-6.153 * (x * x)) + 3.9375 * x;\r\n                        } else {\r\n                            ws_table[i] = 0.630035;\r\n                        }\r\n                    }\r\n                },\r\n                function(amount, n_samples, ws_table) {\r\n                    var a = 2 + Math.round(amount * 14),\r\n                        // we go from 2 to 16 bits, keep in mind for the UI\r\n                        bits = Math.round(Math.pow(2, a - 1)),\r\n                        // real number of quantization steps divided by 2\r\n                        i, x;\r\n                    for (i = 0; i < n_samples; i++) {\r\n                        x = i * 2 / n_samples - 1;\r\n                        ws_table[i] = Math.round(x * bits) / bits;\r\n                    }\r\n                }\r\n            ]\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Panner = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.panner = userContext.createStereoPanner();\r\n        this.output = userContext.createGain();\r\n\r\n        this.activateNode.connect(this.panner);\r\n        this.panner.connect(this.output);\r\n\r\n        this.pan = initValue(properties.pan, this.defaults.pan.value);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Panner.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Panner\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                pan: {\r\n                    value: 0.0,\r\n                    min: -1.0,\r\n                    max: 1.0,\r\n                    automatable: true,\r\n                    type: FLOAT\r\n                }\r\n            }\r\n        },\r\n        pan: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this.panner.pan;\r\n            },\r\n            set: function(value) {\r\n                this.panner.pan.value = value;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Phaser = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.splitter = this.activateNode = userContext.createChannelSplitter(2);\r\n        this.filtersL = [];\r\n        this.filtersR = [];\r\n        this.feedbackGainNodeL = userContext.createGain();\r\n        this.feedbackGainNodeR = userContext.createGain();\r\n        this.merger = userContext.createChannelMerger(2);\r\n        this.filteredSignal = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n        this.lfoL = new userInstance.LFO({\r\n            target: this.filtersL,\r\n            callback: this.callback\r\n        });\r\n        this.lfoR = new userInstance.LFO({\r\n            target: this.filtersR,\r\n            callback: this.callback\r\n        });\r\n\r\n        var i = this.stage;\r\n        while (i--) {\r\n            this.filtersL[i] = userContext.createBiquadFilter();\r\n            this.filtersR[i] = userContext.createBiquadFilter();\r\n            this.filtersL[i].type = \"allpass\";\r\n            this.filtersR[i].type = \"allpass\";\r\n        }\r\n        this.input.connect(this.splitter);\r\n        this.input.connect(this.output);\r\n        this.splitter.connect(this.filtersL[0], 0, 0);\r\n        this.splitter.connect(this.filtersR[0], 1, 0);\r\n        this.connectInOrder(this.filtersL);\r\n        this.connectInOrder(this.filtersR);\r\n        this.filtersL[this.stage - 1].connect(this.feedbackGainNodeL);\r\n        this.filtersL[this.stage - 1].connect(this.merger, 0, 0);\r\n        this.filtersR[this.stage - 1].connect(this.feedbackGainNodeR);\r\n        this.filtersR[this.stage - 1].connect(this.merger, 0, 1);\r\n        this.feedbackGainNodeL.connect(this.filtersL[0]);\r\n        this.feedbackGainNodeR.connect(this.filtersR[0]);\r\n        this.merger.connect(this.output);\r\n\r\n        this.rate = initValue(properties.rate, this.defaults.rate.value);\r\n        this.baseModulationFrequency = properties.baseModulationFrequency || this.defaults.baseModulationFrequency.value;\r\n        this.depth = initValue(properties.depth, this.defaults.depth.value);\r\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\r\n        this.stereoPhase = initValue(properties.stereoPhase, this.defaults.stereoPhase.value);\r\n\r\n        this.lfoL.activate(true);\r\n        this.lfoR.activate(true);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Phaser.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Phaser\"\r\n        },\r\n        stage: {\r\n            value: 4\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                rate: {\r\n                    value: 0.1,\r\n                    min: 0,\r\n                    max: 8,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                depth: {\r\n                    value: 0.6,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                feedback: {\r\n                    value: 0.7,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                stereoPhase: {\r\n                    value: 40,\r\n                    min: 0,\r\n                    max: 180,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                baseModulationFrequency: {\r\n                    value: 700,\r\n                    min: 500,\r\n                    max: 1500,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        callback: {\r\n            value: function(filters, value) {\r\n                for (var stage = 0; stage < 4; stage++) {\r\n                    filters[stage].frequency.value = value;\r\n                }\r\n            }\r\n        },\r\n        depth: {\r\n            get: function() {\r\n                return this._depth;\r\n            },\r\n            set: function(value) {\r\n                this._depth = value;\r\n                this.lfoL.oscillation = this._baseModulationFrequency * this._depth;\r\n                this.lfoR.oscillation = this._baseModulationFrequency * this._depth;\r\n            }\r\n        },\r\n        rate: {\r\n            get: function() {\r\n                return this._rate;\r\n            },\r\n            set: function(value) {\r\n                this._rate = value;\r\n                this.lfoL.frequency = this._rate;\r\n                this.lfoR.frequency = this._rate;\r\n            }\r\n        },\r\n        baseModulationFrequency: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._baseModulationFrequency;\r\n            },\r\n            set: function(value) {\r\n                this._baseModulationFrequency = value;\r\n                this.lfoL.offset = this._baseModulationFrequency;\r\n                this.lfoR.offset = this._baseModulationFrequency;\r\n                this._depth = this._depth;\r\n            }\r\n        },\r\n        feedback: {\r\n            get: function() {\r\n                return this._feedback;\r\n            },\r\n            set: function(value) {\r\n                this._feedback = value;\r\n                this.feedbackGainNodeL.gain.value = this._feedback;\r\n                this.feedbackGainNodeR.gain.value = this._feedback;\r\n            }\r\n        },\r\n        stereoPhase: {\r\n            get: function() {\r\n                return this._stereoPhase;\r\n            },\r\n            set: function(value) {\r\n                this._stereoPhase = value;\r\n                var newPhase = this.lfoL._phase + this._stereoPhase * Math.PI / 180;\r\n                newPhase = fmod(newPhase, 2 * Math.PI);\r\n                this.lfoR._phase = newPhase;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.PingPongDelay = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.wet = userContext.createGain();\r\n        this.stereoToMonoMix = userContext.createGain();\r\n        this.feedbackLevel = userContext.createGain();\r\n        this.output = userContext.createGain();\r\n        this.delayLeft = userContext.createDelay(10);\r\n        this.delayRight = userContext.createDelay(10);\r\n\r\n        this.activateNode = userContext.createGain();\r\n        this.splitter = userContext.createChannelSplitter(2);\r\n        this.merger = userContext.createChannelMerger(2);\r\n\r\n        this.activateNode.connect(this.splitter);\r\n        this.splitter.connect(this.stereoToMonoMix, 0, 0);\r\n        this.splitter.connect(this.stereoToMonoMix, 1, 0);\r\n        this.stereoToMonoMix.gain.value = .5;\r\n        this.stereoToMonoMix.connect(this.wet);\r\n        this.wet.connect(this.delayLeft);\r\n        this.feedbackLevel.connect(this.wet);\r\n        this.delayLeft.connect(this.delayRight);\r\n        this.delayRight.connect(this.feedbackLevel);\r\n        this.delayLeft.connect(this.merger, 0, 0);\r\n        this.delayRight.connect(this.merger, 0, 1);\r\n        this.merger.connect(this.output);\r\n        this.activateNode.connect(this.output);\r\n\r\n        this.delayTimeLeft = properties.delayTimeLeft !== undefined ? properties.delayTimeLeft : this.defaults.delayTimeLeft.value;\r\n        this.delayTimeRight = properties.delayTimeRight !== undefined ? properties.delayTimeRight : this.defaults.delayTimeRight.value;\r\n        this.feedbackLevel.gain.value = properties.feedback !== undefined ? properties.feedback : this.defaults.feedback.value;\r\n        this.wet.gain.value = properties.wetLevel !== undefined ? properties.wetLevel : this.defaults.wetLevel.value;\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.PingPongDelay.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"PingPongDelay\"\r\n        },\r\n        delayTimeLeft: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._delayTimeLeft;\r\n            },\r\n            set: function(value) {\r\n                this._delayTimeLeft = value;\r\n                this.delayLeft.delayTime.value = value / 1000;\r\n            }\r\n        },\r\n        delayTimeRight: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._delayTimeRight;\r\n            },\r\n            set: function(value) {\r\n                this._delayTimeRight = value;\r\n                this.delayRight.delayTime.value = value / 1000;\r\n            }\r\n        },\r\n        wetLevel: {\r\n            enumerable: true,\r\n            get: function () {\r\n                return this.wet.gain;\r\n            },\r\n            set: function (value) {\r\n                this.wet.gain.value = value;\r\n            }\r\n        }, \r\n        feedback: {\r\n            enumerable: true,\r\n            get: function () {\r\n                return this.feedbackLevel.gain;\r\n            },\r\n            set: function (value) {\r\n                this.feedbackLevel.gain.value = value;\r\n            }\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                delayTimeLeft: {\r\n                    value: 200,\r\n                    min: 1,\r\n                    max: 10000,\r\n                    automatable: false,\r\n                    type: INT\r\n                },\r\n                delayTimeRight: {\r\n                    value: 400,\r\n                    min: 1,\r\n                    max: 10000,\r\n                    automatable: false,\r\n                    type: INT\r\n                },\r\n                feedback: {\r\n                    value: 0.3,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                wetLevel: {\r\n                    value: 0.5,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.Tremolo = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.splitter = this.activateNode = userContext.createChannelSplitter(\r\n                2),\r\n            this.amplitudeL = userContext.createGain(),\r\n            this.amplitudeR = userContext.createGain(),\r\n            this.merger = userContext.createChannelMerger(2),\r\n            this.output = userContext.createGain();\r\n        this.lfoL = new userInstance.LFO({\r\n            target: this.amplitudeL.gain,\r\n            callback: pipe\r\n        });\r\n        this.lfoR = new userInstance.LFO({\r\n            target: this.amplitudeR.gain,\r\n            callback: pipe\r\n        });\r\n\r\n        this.input.connect(this.splitter);\r\n        this.splitter.connect(this.amplitudeL, 0);\r\n        this.splitter.connect(this.amplitudeR, 1);\r\n        this.amplitudeL.connect(this.merger, 0, 0);\r\n        this.amplitudeR.connect(this.merger, 0, 1);\r\n        this.merger.connect(this.output);\r\n\r\n        this.rate = properties.rate || this.defaults.rate.value;\r\n        this.intensity = initValue(properties.intensity, this.defaults.intensity.value);\r\n        this.stereoPhase = initValue(properties.stereoPhase, this.defaults.stereoPhase.value);\r\n\r\n        this.lfoL.offset = 1 - (this.intensity / 2);\r\n        this.lfoR.offset = 1 - (this.intensity / 2);\r\n        this.lfoL.phase = this.stereoPhase * Math.PI / 180;\r\n\r\n        this.lfoL.activate(true);\r\n        this.lfoR.activate(true);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.Tremolo.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"Tremolo\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                intensity: {\r\n                    value: 0.3,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                stereoPhase: {\r\n                    value: 0,\r\n                    min: 0,\r\n                    max: 180,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                rate: {\r\n                    value: 5,\r\n                    min: 0.1,\r\n                    max: 11,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        intensity: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._intensity;\r\n            },\r\n            set: function(value) {\r\n                this._intensity = value;\r\n                this.lfoL.offset = 1 - this._intensity / 2;\r\n                this.lfoR.offset = 1 - this._intensity / 2;\r\n                this.lfoL.oscillation = this._intensity;\r\n                this.lfoR.oscillation = this._intensity;\r\n            }\r\n        },\r\n        rate: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._rate;\r\n            },\r\n            set: function(value) {\r\n                this._rate = value;\r\n                this.lfoL.frequency = this._rate;\r\n                this.lfoR.frequency = this._rate;\r\n            }\r\n        },\r\n        stereoPhase: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._stereoPhase;\r\n            },\r\n            set: function(value) {\r\n                this._stereoPhase = value;\r\n                var newPhase = this.lfoL._phase + this._stereoPhase * Math.PI / 180;\r\n                newPhase = fmod(newPhase, 2 * Math.PI);\r\n                this.lfoR.phase = newPhase;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.WahWah = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.activateNode = userContext.createGain();\r\n        this.envelopeFollower = new userInstance.EnvelopeFollower({\r\n            target: this,\r\n            callback: function(context, value) {\r\n                context.sweep = value;\r\n            }\r\n        });\r\n        this.filterBp = userContext.createBiquadFilter();\r\n        this.filterPeaking = userContext.createBiquadFilter();\r\n        this.output = userContext.createGain();\r\n\r\n        //Connect AudioNodes\r\n        this.activateNode.connect(this.filterBp);\r\n        this.filterBp.connect(this.filterPeaking);\r\n        this.filterPeaking.connect(this.output);\r\n\r\n        //Set Properties\r\n        this.init();\r\n        this.automode = initValue(properties.automode, this.defaults.automode.value);\r\n        this.resonance = properties.resonance || this.defaults.resonance.value;\r\n        this.sensitivity = initValue(properties.sensitivity, this.defaults.sensitivity.value);\r\n        this.baseFrequency = initValue(properties.baseFrequency, this.defaults.baseFrequency.value);\r\n        this.excursionOctaves = properties.excursionOctaves || this.defaults.excursionOctaves.value;\r\n        this.sweep = initValue(properties.sweep, this.defaults.sweep.value);\r\n\r\n        this.activateNode.gain.value = 2;\r\n        this.envelopeFollower.activate(true);\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.WahWah.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"WahWah\"\r\n        },\r\n        defaults: {\r\n            writable: true,\r\n            value: {\r\n                automode: {\r\n                    value: true,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                },\r\n                baseFrequency: {\r\n                    value: 0.5,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                excursionOctaves: {\r\n                    value: 2,\r\n                    min: 1,\r\n                    max: 6,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                sweep: {\r\n                    value: 0.2,\r\n                    min: 0,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                resonance: {\r\n                    value: 10,\r\n                    min: 1,\r\n                    max: 100,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                sensitivity: {\r\n                    value: 0.5,\r\n                    min: -1,\r\n                    max: 1,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        automode: {\r\n            get: function() {\r\n                return this._automode;\r\n            },\r\n            set: function(value) {\r\n                this._automode = value;\r\n                if (value) {\r\n                    this.activateNode.connect(this.envelopeFollower.input);\r\n                    this.envelopeFollower.activate(true);\r\n                } else {\r\n                    this.envelopeFollower.activate(false);\r\n                    this.activateNode.disconnect();\r\n                    this.activateNode.connect(this.filterBp);\r\n                }\r\n            }\r\n        },\r\n        filterFreqTimeout: {\r\n            value: 0\r\n        },\r\n        setFilterFreq: {\r\n            value: function() {\r\n                try {\r\n                    this.filterBp.frequency.value = Math.min(22050, this._baseFrequency + this._excursionFrequency * this._sweep);\r\n                    this.filterPeaking.frequency.value = Math.min(22050, this._baseFrequency + this._excursionFrequency * this._sweep);\r\n                } catch (e) {\r\n                    clearTimeout(this.filterFreqTimeout);\r\n                    //put on the next cycle to let all init properties be set\r\n                    this.filterFreqTimeout = setTimeout(function() {\r\n                        this.setFilterFreq();\r\n                    }.bind(this), 0);\r\n                }\r\n            }\r\n        },\r\n        sweep: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._sweep;\r\n            },\r\n            set: function(value) {\r\n                this._sweep = Math.pow(value > 1 ? 1 : value < 0 ? 0 : value, this._sensitivity);\r\n                this.setFilterFreq();\r\n            }\r\n        },\r\n        baseFrequency: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._baseFrequency;\r\n            },\r\n            set: function(value) {\r\n                this._baseFrequency = 50 * Math.pow(10, value * 2);\r\n                this._excursionFrequency = Math.min(userContext.sampleRate / 2, this.baseFrequency * Math.pow(2, this._excursionOctaves));\r\n                this.setFilterFreq();\r\n            }\r\n        },\r\n        excursionOctaves: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._excursionOctaves;\r\n            },\r\n            set: function(value) {\r\n                this._excursionOctaves = value;\r\n                this._excursionFrequency = Math.min(userContext.sampleRate / 2, this.baseFrequency * Math.pow(2, this._excursionOctaves));\r\n                this.setFilterFreq();\r\n            }\r\n        },\r\n        sensitivity: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._sensitivity;\r\n            },\r\n            set: function(value) {\r\n                this._sensitivity = Math.pow(10, value);\r\n            }\r\n        },\r\n        resonance: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._resonance;\r\n            },\r\n            set: function(value) {\r\n                this._resonance = value;\r\n                this.filterPeaking.Q = this._resonance;\r\n            }\r\n        },\r\n        init: {\r\n            value: function() {\r\n                this.output.gain.value = 1;\r\n                this.filterPeaking.type = \"peaking\";\r\n                this.filterBp.type = \"bandpass\";\r\n                this.filterPeaking.frequency.value = 100;\r\n                this.filterPeaking.gain.value = 20;\r\n                this.filterPeaking.Q.value = 5;\r\n                this.filterBp.frequency.value = 100;\r\n                this.filterBp.Q.value = 1;\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.EnvelopeFollower = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n        this.input = userContext.createGain();\r\n        this.jsNode = this.output = userContext.createScriptProcessor(this.buffersize, 1, 1);\r\n\r\n        this.input.connect(this.output);\r\n\r\n        this.attackTime = initValue(properties.attackTime, this.defaults.attackTime.value);\r\n        this.releaseTime = initValue(properties.releaseTime, this.defaults.releaseTime.value);\r\n        this._envelope = 0;\r\n        this.target = properties.target || {};\r\n        this.callback = properties.callback || function() {};\r\n\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.EnvelopeFollower.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"EnvelopeFollower\"\r\n        },\r\n        defaults: {\r\n            value: {\r\n                attackTime: {\r\n                    value: 0.003,\r\n                    min: 0,\r\n                    max: 0.5,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                releaseTime: {\r\n                    value: 0.5,\r\n                    min: 0,\r\n                    max: 0.5,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        buffersize: {\r\n            value: 256\r\n        },\r\n        envelope: {\r\n            value: 0\r\n        },\r\n        sampleRate: {\r\n            value: 44100\r\n        },\r\n        attackTime: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._attackTime;\r\n            },\r\n            set: function(value) {\r\n                this._attackTime = value;\r\n                this._attackC = Math.exp(-1 / this._attackTime * this.sampleRate / this.buffersize);\r\n            }\r\n        },\r\n        releaseTime: {\r\n            enumerable: true,\r\n            get: function() {\r\n                return this._releaseTime;\r\n            },\r\n            set: function(value) {\r\n                this._releaseTime = value;\r\n                this._releaseC = Math.exp(-1 / this._releaseTime * this.sampleRate / this.buffersize);\r\n            }\r\n        },\r\n        callback: {\r\n            get: function() {\r\n                return this._callback;\r\n            },\r\n            set: function(value) {\r\n                if (typeof value === \"function\") {\r\n                    this._callback = value;\r\n                } else {\r\n                    console.error(\"tuna.js: \" + this.name + \": Callback must be a function!\");\r\n                }\r\n            }\r\n        },\r\n        target: {\r\n            get: function() {\r\n                return this._target;\r\n            },\r\n            set: function(value) {\r\n                this._target = value;\r\n            }\r\n        },\r\n        activate: {\r\n            value: function(doActivate) {\r\n                this.activated = doActivate;\r\n                if (doActivate) {\r\n                    this.jsNode.connect(userContext.destination);\r\n                    this.jsNode.onaudioprocess = this.returnCompute(this);\r\n                } else {\r\n                    this.jsNode.disconnect();\r\n                    this.jsNode.onaudioprocess = null;\r\n                }\r\n                if (this.activateCallback) {\r\n                    this.activateCallback(doActivate);\r\n                }\r\n            }\r\n        },\r\n        returnCompute: {\r\n            value: function(instance) {\r\n                return function(event) {\r\n                    instance.compute(event);\r\n                };\r\n            }\r\n        },\r\n        compute: {\r\n            value: function(event) {\r\n                var count = event.inputBuffer.getChannelData(0).length,\r\n                    channels = event.inputBuffer.numberOfChannels,\r\n                    current, chan, rms, i;\r\n                chan = rms = i = 0;\r\n                if (channels > 1) { //need to mixdown\r\n                    for (i = 0; i < count; ++i) {\r\n                        for (; chan < channels; ++chan) {\r\n                            current = event.inputBuffer.getChannelData(chan)[i];\r\n                            rms += (current * current) / channels;\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (i = 0; i < count; ++i) {\r\n                        current = event.inputBuffer.getChannelData(0)[i];\r\n                        rms += (current * current);\r\n                    }\r\n                }\r\n                rms = Math.sqrt(rms);\r\n\r\n                if (this._envelope < rms) {\r\n                    this._envelope *= this._attackC;\r\n                    this._envelope += (1 - this._attackC) * rms;\r\n                } else {\r\n                    this._envelope *= this._releaseC;\r\n                    this._envelope += (1 - this._releaseC) * rms;\r\n                }\r\n                this._callback(this._target, this._envelope);\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.prototype.LFO = function(properties) {\r\n        if (!properties) {\r\n            properties = this.getDefaults();\r\n        }\r\n\r\n        //Instantiate AudioNode\r\n        this.input = userContext.createGain();\r\n        this.output = userContext.createScriptProcessor(256, 1, 1);\r\n        this.activateNode = userContext.destination;\r\n\r\n        //Set Properties\r\n        this.frequency = initValue(properties.frequency, this.defaults.frequency.value);\r\n        this.offset = initValue(properties.offset, this.defaults.offset.value);\r\n        this.oscillation = initValue(properties.oscillation, this.defaults.oscillation.value);\r\n        this.phase = initValue(properties.phase, this.defaults.phase.value);\r\n        this.target = properties.target || {};\r\n        this.output.onaudioprocess = this.callback(properties.callback || function() {});\r\n        this.bypass = properties.bypass || this.defaults.bypass.value;\r\n    };\r\n    Tuna.prototype.LFO.prototype = Object.create(Super, {\r\n        name: {\r\n            value: \"LFO\"\r\n        },\r\n        bufferSize: {\r\n            value: 256\r\n        },\r\n        sampleRate: {\r\n            value: 44100\r\n        },\r\n        defaults: {\r\n            value: {\r\n                frequency: {\r\n                    value: 1,\r\n                    min: 0,\r\n                    max: 20,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                offset: {\r\n                    value: 0.85,\r\n                    min: 0,\r\n                    max: 22049,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                oscillation: {\r\n                    value: 0.3,\r\n                    min: -22050,\r\n                    max: 22050,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                phase: {\r\n                    value: 0,\r\n                    min: 0,\r\n                    max: 2 * Math.PI,\r\n                    automatable: false,\r\n                    type: FLOAT\r\n                },\r\n                bypass: {\r\n                    value: false,\r\n                    automatable: false,\r\n                    type: BOOLEAN\r\n                }\r\n            }\r\n        },\r\n        frequency: {\r\n            get: function() {\r\n                return this._frequency;\r\n            },\r\n            set: function(value) {\r\n                this._frequency = value;\r\n                this._phaseInc = 2 * Math.PI * this._frequency * this.bufferSize / this.sampleRate;\r\n            }\r\n        },\r\n        offset: {\r\n            get: function() {\r\n                return this._offset;\r\n            },\r\n            set: function(value) {\r\n                this._offset = value;\r\n            }\r\n        },\r\n        oscillation: {\r\n            get: function() {\r\n                return this._oscillation;\r\n            },\r\n            set: function(value) {\r\n                this._oscillation = value;\r\n            }\r\n        },\r\n        phase: {\r\n            get: function() {\r\n                return this._phase;\r\n            },\r\n            set: function(value) {\r\n                this._phase = value;\r\n            }\r\n        },\r\n        target: {\r\n            get: function() {\r\n                return this._target;\r\n            },\r\n            set: function(value) {\r\n                this._target = value;\r\n            }\r\n        },\r\n        activate: {\r\n            value: function(doActivate) {\r\n                if (doActivate) {\r\n                    this.output.connect(userContext.destination);\r\n                    if (this.activateCallback) {\r\n                        this.activateCallback(doActivate);\r\n                    }\r\n                } else {\r\n                    this.output.disconnect();\r\n                }\r\n            }\r\n        },\r\n        callback: {\r\n            value: function(callback) {\r\n                var that = this;\r\n                return function() {\r\n                    that._phase += that._phaseInc;\r\n                    if (that._phase > 2 * Math.PI) {\r\n                        that._phase = 0;\r\n                    }\r\n                    callback(that._target, that._offset + that._oscillation * Math.sin(that._phase));\r\n                };\r\n            }\r\n        }\r\n    });\r\n\r\n    Tuna.toString = Tuna.prototype.toString = function() {\r\n        return \"Please visit https://github.com/Theodeus/tuna/wiki for instructions on how to use Tuna.js\";\r\n    };\r\n})();\r\n","module.exports = function(originalModule) {\r\n\tif (!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n","import Tuna from 'tunajs';\n\n/** Let's do the vendor-prefix dance. **/\nvar audioContext = window.AudioContext || window.webkitAudioContext;\n\nvar aScene = document.querySelector('a-scene');\nvar context;\nif ( aScene && aScene.audioListener && aScene.audioListener.context){\n    context = aScene.audioListener.context\n    console.log(\"An A-Frame scene has been detected.\")\n}\nelse {\n    context = new audioContext();\n}\n\n// create a wrapper for old versions of `getUserMedia`\nvar getUserMedia = (function(window) {\n    if (window.navigator.mediaDevices && window.navigator.mediaDevices.getUserMedia) {\n        // Browser supports promise based `getUserMedia`\n        return window.navigator.mediaDevices.getUserMedia.bind(window.navigator.mediaDevices);\n    }\n    var navigatorGetUserMedia = window.navigator.getUserMedia || window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia;\n    if (navigatorGetUserMedia) {\n        // Browser supports old `getUserMedia` with callbacks.\n        return function(constraints) {\n            return new Promise(function(resolve, reject) {\n                navigatorGetUserMedia.call(window.navigator, constraints, resolve, reject);\n            });\n        };\n    }\n\n    return function() {\n        throw \"getUserMedia is unsupported\";\n    };\n}(window));\n\nif (getUserMedia)\n    console.log(\"Your browser supports getUserMedia.\");\nelse\n    console.log(\"Your browser does not support getUserMedia.\");\n/////////////////////////////////////////\n\nvar Wad = (function(){\n\n/** Pre-render a noise buffer instead of generating noise on the fly. **/\n    var noiseBuffer = (function(){\n        // the initial seed\n        Math.seed = 6;\n        Math.seededRandom = function(max, min){\n            max = max || 1;\n            min = min || 0;\n            Math.seed = ( Math.seed * 9301 + 49297 ) % 233280;\n            var rnd = Math.seed / 233280;\n\n            return min + rnd * (max - min);\n        }\n        var bufferSize = 2 * context.sampleRate;\n        var noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);\n        var output = noiseBuffer.getChannelData(0);\n        for ( var i = 0; i < bufferSize; i++ ) {\n            output[i] = Math.seededRandom() * 2 - 1;\n        }\n        return noiseBuffer;\n    })()\n/////////////////////////////////////////////////////////////////////////\n\n/** a lil hack. just be glad it isn't on Object.prototype. **/\n    var isArray = function(object){\n        return Object.prototype.toString.call(object) === '[object Array]';\n    }\n\n/** Set up the default ADSR envelope. **/\n    var constructEnv = function(that, arg){\n        that.env = { //default envelope, if one is not specified on play\n            attack  : arg.env ? valueOrDefault(arg.env.attack,  1) : 0,    // time in seconds from onset to peak volume\n            decay   : arg.env ? valueOrDefault(arg.env.decay,   0) : 0,    // time in seconds from peak volume to sustain volume\n            sustain : arg.env ? valueOrDefault(arg.env.sustain, 1) : 1,    // sustain volume level, as a percent of peak volume. min:0, max:1\n            hold    : arg.env ? valueOrDefault(arg.env.hold, 3.14159) : 3.14159, // time in seconds to maintain sustain volume\n            release : arg.env ? valueOrDefault(arg.env.release, 0) : 0     // time in seconds from sustain volume to zero volume\n        };\n        that.defaultEnv = {\n            attack  : arg.env ? valueOrDefault(arg.env.attack,  1) : 0,    // time in seconds from onset to peak volume\n            decay   : arg.env ? valueOrDefault(arg.env.decay,   0) : 0,    // time in seconds from peak volume to sustain volume\n            sustain : arg.env ? valueOrDefault(arg.env.sustain, 1) : 1,    // sustain volume level, as a percent of peak volume. min:0, max:1\n            hold    : arg.env ? valueOrDefault(arg.env.hold, 3.14159) : 3.14159, // time in seconds to maintain sustain volume\n            release : arg.env ? valueOrDefault(arg.env.release, 0) : 0     // time in seconds from sustain volume to zero volume\n        };\n    }\n/////////////////////////////////////////\n\n\n/** Set up the default filter and filter envelope. **/\n    var constructFilter = function(that, arg){\n\n        if ( !arg.filter ) { arg.filter = null; }\n\n        else if ( isArray(arg.filter) ) {\n            that.filter = arg.filter.map(function(filterArg){\n                return {\n                    type : filterArg.type || 'lowpass',\n                    frequency : filterArg.frequency || 600,\n                    q : filterArg.q || 1,\n                    env : filterArg.env || null,\n                }\n            });\n        }\n        else {\n            that.filter  = [{\n                type : arg.filter.type || 'lowpass',\n                frequency : arg.filter.frequency || 600,\n                q : arg.filter.q || 1,\n                env : arg.filter.env ||null,\n            }];\n        }\n    }\n//////////////////////////////////////////////////////\n\n\n/** If the Wad uses an audio file as the source, request it from the server.\nDon't let the Wad play until all necessary files have been downloaded. **/\n    var requestAudioFile = function(that, callback){\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", that.source, true);\n        request.responseType = \"arraybuffer\";\n        that.playable--;\n        request.onload = function(){\n            context.decodeAudioData(request.response, function (decodedBuffer){\n                that.decodedBuffer = decodedBuffer;\n                if ( that.env.hold === 3.14159 ) { // audio buffers should not use the default hold\n                    that.env.hold = that.decodedBuffer.duration + 1\n                }\n                if ( callback ) { callback(that); }\n                that.playable++;\n                if ( that.playOnLoad ) { that.play(that.playOnLoadArg); }\n            })\n        };\n        request.send();\n    };\n//////////////////////////////////////////////////////////////////////////\n\n/** Set up the vibrato LFO **/\n    var constructVibrato = function(that, arg){\n        if ( arg.vibrato ) {\n            that.vibrato = {\n                shape     : valueOrDefault(arg.vibrato.shape, 'sine'),\n                speed     : valueOrDefault(arg.vibrato.speed, 1),\n                magnitude : valueOrDefault(arg.vibrato.magnitude, 5),\n                attack    : valueOrDefault(arg.vibrato.attack, 0)\n            };\n        }\n        else { that.vibrato = null; }\n    };\n//////////////////////////////\n\n\n/** Set up the tremolo LFO **/\n    var constructTremolo = function(that, arg){\n        if ( arg.tremolo ) {\n            that.tremolo = {\n                shape     : valueOrDefault(arg.tremolo.shape, 'sine'),\n                speed     : valueOrDefault(arg.tremolo.speed, 1),\n                magnitude : valueOrDefault(arg.tremolo.magnitude, 5),\n                attack    : valueOrDefault(arg.tremolo.attack, 1)\n            };\n        }\n        else { that.tremolo = null; }\n    };\n//////////////////////////////\n\n/** Grab the reverb impulse response file from a server.\nYou may want to change Wad.defaultImpulse to serve files from your own server.\nCheck out http://www.voxengo.com/impulses/ for free impulse responses. **/\n    var constructReverb = function(that, arg){\n        if ( arg.reverb ) {\n            that.reverb = { wet : valueOrDefault(arg.reverb.wet, 1) };\n            var impulseURL = arg.reverb.impulse || Wad.defaultImpulse;\n            var request = new XMLHttpRequest();\n            request.open(\"GET\", impulseURL, true);\n            request.responseType = \"arraybuffer\";\n            that.playable--;\n            request.onload = function(){\n                context.decodeAudioData(request.response, function (decodedBuffer){\n\n                    that.reverb.buffer = decodedBuffer;\n                    that.playable++;\n                    if ( that.playOnLoad ) { that.play(that.playOnLoadArg); }\n                    if ( that instanceof Wad.Poly ) { that.setUp(arg); }\n                    if ( that.source === 'mic' && that.reverb && that.reverb.buffer && that.reverb.node && !that.reverb.node.buffer ) { // I think this is only relevant when calling play() with args on a mic\n                        that.reverb.node.convolver.buffer = that.reverb.buffer;\n                    }\n\n                })\n            };\n            request.send();\n        }\n        else {\n            that.reverb = null;\n        }\n    };\n\n    var constructPanning = function(that, arg){\n        if ( 'panning' in arg ) {\n            that.panning = { location : arg.panning };\n            if ( typeof(arg.panning) === \"number\" ) {\n                that.panning.type = 'stereo';\n            }\n\n            else {\n                that.panning.type = '3d'\n                that.panning.panningModel = arg.panningModel || 'equalpower';\n            }\n        }\n\n        else {\n            that.panning = {\n                location : 0,\n                type     : 'stereo',\n            };\n        }\n        if ( that.panning.type === 'stereo' && !context.createStereoPanner ) {\n            console.log(\"Your browser does not support stereo panning. Falling back to 3D panning.\")\n            that.panning = {\n                location     : [0,0,0],\n                type         : '3d',\n                panningModel : 'equalpower',\n            }\n        }\n    };\n//////////////////////////////////////////////////////////////////////////////\n    var constructDelay = function(that, arg){\n        if ( arg.delay ) {\n            that.delay = {\n                delayTime    : valueOrDefault(arg.delay.delayTime, .5),\n                maxDelayTime : valueOrDefault(arg.delay.maxDelayTime, 2),\n                feedback     : valueOrDefault(arg.delay.feedback, .25),\n                wet          : valueOrDefault(arg.delay.wet, .25)\n            };\n        }\n        else { that.delay = null; }\n    };\n/** Special initialization and configuration for microphone Wads **/\n    var getConsent = function(that, arg) {\n        that.nodes             = [];\n        that.mediaStreamSource = null;\n        that.gain              = null;\n        return getUserMedia({audio: true, video: false}).then(function(stream) {\n            // console.log('got stream')\n            that.mediaStreamSource = context.createMediaStreamSource(stream);\n            Wad.micConsent = true\n            setUpMic(that, arg);\n            return that;\n        }).catch(function(error) { console.log('Error setting up microphone input: ', error); }); // This is the error callback.\n    };\n////////////////////////////////////////////////////////////////////\n\n    var setUpMic = function(that, arg){\n        that.nodes           = [];\n        that.gain            = context.createGain();\n        that.gain.gain.value = valueOrDefault(arg.volume,that.volume);\n        that.nodes.push(that.mediaStreamSource);\n        that.nodes.push(that.gain);\n        // console.log('that ', arg)\n\n        if ( that.filter || arg.filter ) { createFilters(that, arg); }\n\n        if ( that.reverb || arg.reverb ) { setUpReverbOnPlay(that, arg); }\n\n        constructPanning(that, arg);\n        setUpPanningOnPlay(that, arg);\n\n        if ( that.delay || arg.delay ) {\n            setUpDelayOnPlay(that, arg);\n        }\n        setUpTunaOnPlay(that, arg)\n        that.setUpExternalFxOnPlay(arg, context);\n    }\n\n    var Wad = function(arg){\n/** Set basic Wad properties **/\n        this.source        = arg.source;\n        this.destination   = arg.destination || context.destination; // the last node the sound is routed to\n        this.volume        = valueOrDefault(arg.volume, 1); // peak volume. min:0, max:1 (actually max is infinite, but ...just keep it at or below 1)\n        this.defaultVolume = this.volume;\n        this.playable      = 1; // if this is less than 1, this Wad is still waiting for a file to download before it can play\n        this.pitch         = Wad.pitches[arg.pitch] || arg.pitch || 440;\n        this.gain          = [];\n        this.detune        = arg.detune || 0; // In Cents.\n        this.globalReverb  = arg.globalReverb || false;\n        this.offset        = arg.offset || 0;\n        this.loop          = arg.loop   || false;\n        this.tuna          = arg.tuna   || null;\n        this.rate          = arg.rate   || 1;\n        constructEnv(this, arg);\n        constructFilter(this, arg);\n        constructVibrato(this, arg);\n        constructTremolo(this, arg);\n        constructReverb(this, arg);\n        this.constructExternalFx(arg, context);\n        constructPanning(this, arg);\n        constructDelay(this, arg);\n////////////////////////////////\n\n\n/** If the Wad's source is noise, set the Wad's buffer to the noise buffer we created earlier. **/\n        if ( this.source === 'noise' ) {\n            this.decodedBuffer = noiseBuffer;\n        }\n//////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/** If the Wad's source is the microphone, the rest of the setup happens here. **/\n        else if ( this.source === 'mic' ) {\n            getConsent(this, arg);\n        }\n//////////////////////////////////////////////////////////////////////////////////\n\n\n/** If the source is not a pre-defined value, assume it is a URL for an audio file, and grab it now. **/\n        else if ( !( this.source in { 'sine' : 0, 'sawtooth' : 0, 'square' : 0, 'triangle' : 0 } ) ) {\n            requestAudioFile(this, arg.callback);\n        }\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n        else { arg.callback && arg.callback(this) }\n    };\n\n    Wad.micConsent = false\n    Wad.audioContext = context\n    if ( typeof Tuna != undefined ) {\n        Wad.tuna = new Tuna(Wad.audioContext)\n    }\n\n\n/** When a note is played, these two functions will schedule changes in volume and filter frequency,\nas specified by the volume envelope and filter envelope **/\n    var filterEnv = function(wad, arg){\n        wad.filter.forEach(function (filter, index){\n            filter.node.frequency.linearRampToValueAtTime(filter.frequency, arg.exactTime);\n            filter.node.frequency.linearRampToValueAtTime(filter.env.frequency, arg.exactTime + filter.env.attack);\n        });\n    };\n\n    var playEnv = function(wad, arg){\n        wad.gain[0].gain.linearRampToValueAtTime(0.0001, arg.exactTime);\n        wad.gain[0].gain.linearRampToValueAtTime(wad.volume, arg.exactTime + wad.env.attack + 0.00001);\n        wad.gain[0].gain.linearRampToValueAtTime(wad.volume * wad.env.sustain, arg.exactTime + wad.env.attack + wad.env.decay + 0.00002);\n        wad.gain[0].gain.linearRampToValueAtTime(wad.volume * wad.env.sustain, arg.exactTime + wad.env.attack + wad.env.decay + wad.env.hold + 0.00003);\n        wad.gain[0].gain.linearRampToValueAtTime(0.0001, arg.exactTime + wad.env.attack + wad.env.decay + wad.env.hold + wad.env.release + 0.00004);\n        // offset is only used by BufferSourceNodes. OscillatorNodes should safely ignore the offset.\n        wad.soundSource.start(arg.exactTime, arg.offset);\n        wad.soundSource.stop(arg.exactTime + wad.env.attack + wad.env.decay + wad.env.hold + wad.env.release);\n    };\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/** When all the nodes are set up for this Wad, this function plugs them into each other,\nwith special handling for nodes with custom interfaces (e.g. reverb, delay). **/\n    var plugEmIn = function(that, arg){\n        // console.log('nodes? ', that.nodes)\n        var destination = ( arg && arg.destination ) || that.destination;\n        for ( var i = 1; i < that.nodes.length; i++ ) {\n            if (that.nodes[i-1] && that.nodes[i-1].interface === 'custom' ) {\n                var from = that.nodes[i-1].output;\n            }\n            else { // assume native interface\n                var from = that.nodes[i-1];\n            }\n            if (that.nodes[i] && that.nodes[i].interface === 'custom' ) {\n                var to = that.nodes[i].input\n            }\n            else { // assume native interface\n                var to = that.nodes[i]\n            }\n            if(from)\n                from.connect(to);\n        }\n        if (that.nodes[that.nodes.length-1] && that.nodes[that.nodes.length-1].interface === 'custom') {\n            var lastStop = that.nodes[that.nodes.length-1].output;\n        }\n        else { // assume native interface\n            var lastStop = that.nodes[that.nodes.length-1];\n        }\n        if(lastStop)\n        lastStop.connect(destination);\n\n        /** Global reverb is super deprecated, and should be removed at some point. **/\n        if ( Wad.reverb && that.globalReverb ) {\n            if(that.nodes[that.nodes.length - 1])\n            that.nodes[that.nodes.length - 1].connect(Wad.reverb.node);\n            if(Wad.reverb.node)\n            Wad.reverb.node.connect(Wad.reverb.gain);\n            if(Wad.reverb.gain)\n            Wad.reverb.gain.connect(destination);\n        }\n        /**************************************************************************/\n    };\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n/** Initialize and configure an oscillator node **/\n    var setUpOscillator = function(that, arg){\n        arg = arg || {};\n        that.soundSource = context.createOscillator();\n        that.soundSource.type = that.source;\n        if ( arg.pitch ) {\n            if ( arg.pitch in Wad.pitches ) {\n                that.soundSource.frequency.value = Wad.pitches[arg.pitch];\n            }\n            else {\n                that.soundSource.frequency.value = arg.pitch;\n            }\n        }\n        else {\n            that.soundSource.frequency.value = that.pitch;\n        }\n    };\n///////////////////////////////////////////////////\n\n/** Set the ADSR volume envelope according to play() arguments, or revert to defaults **/\n    var setUpEnvOnPlay = function(that, arg){\n        if ( arg && arg.env ) {\n            that.env.attack  = valueOrDefault(arg.env.attack, that.defaultEnv.attack);\n            that.env.decay   = valueOrDefault(arg.env.decay, that.defaultEnv.decay);\n            that.env.sustain = valueOrDefault(arg.env.sustain, that.defaultEnv.sustain);\n            that.env.hold    = valueOrDefault(arg.env.hold, that.defaultEnv.hold);\n            that.env.release = valueOrDefault(arg.env.release, that.defaultEnv.release);\n        }\n        else {\n            that.env = {\n                attack  : that.defaultEnv.attack,\n                decay   : that.defaultEnv.decay,\n                sustain : that.defaultEnv.sustain,\n                hold    : that.defaultEnv.hold,\n                release : that.defaultEnv.release\n            };\n        }\n    };\n//////////////////////////////////////////////////////////////////////////////////\n\n\n/** Set the filter and filter envelope according to play() arguments, or revert to defaults **/\n\n    var createFilters = function(that, arg){\n        if ( arg.filter && !isArray(arg.filter) ) {\n            arg.filter = [arg.filter];\n        }\n        that.filter.forEach(function (filter, i) {\n            filter.node                 = context.createBiquadFilter();\n            filter.node.type            = filter.type;\n            filter.node.frequency.value = ( arg.filter && arg.filter[i] ) ? ( arg.filter[i].frequency || filter.frequency ) : filter.frequency;\n            filter.node.Q.value         = ( arg.filter && arg.filter[i] ) ? ( arg.filter[i].q         || filter.q )         : filter.q;\n            if ( ( arg.filter && arg.filter[i].env || that.filter[i].env ) && !( that.source === \"mic\" ) ) {\n                filter.env = {\n                    attack    : ( arg.filter && arg.filter[i].env && arg.filter[i].env.attack )    || that.filter[i].env.attack,\n                    frequency : ( arg.filter && arg.filter[i].env && arg.filter[i].env.frequency ) || that.filter[i].env.frequency\n                };\n            }\n\n            that.nodes.push(filter.node);\n        })\n    };\n\n    var setUpFilterOnPlay = function(that, arg){\n        if ( arg && arg.filter && that.filter ) {\n            if ( !isArray(arg.filter) ) arg.filter = [arg.filter]\n            createFilters(that, arg)\n        }\n        else if ( that.filter ) {\n            createFilters(that, that);\n        }\n    };\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n/** Initialize and configure a convolver node for playback **/\n    var setUpReverbOnPlay = function(that, arg){\n        var reverbNode = {\n            interface : 'custom',\n            input : context.createGain(),\n            convolver : context.createConvolver(),\n            wet : context.createGain(),\n            output : context.createGain()\n        }\n        reverbNode.convolver.buffer = that.reverb.buffer;\n        reverbNode.wet.gain.value   = that.reverb.wet;\n\n        if(reverbNode.input){\n            reverbNode.input.connect(reverbNode.convolver);\n            reverbNode.input.connect(reverbNode.output);\n        }\n        if(reverbNode.convolver)\n        reverbNode.convolver.connect(reverbNode.wet);\n        if(reverbNode.wet)\n        reverbNode.wet.connect(reverbNode.output);\n\n        that.reverb.node = reverbNode;\n        that.nodes.push(that.reverb.node);\n    };\n//////////////////////////////////////////////////////////////\n\n\n/** Initialize and configure a panner node for playback **/\n    var setUpPanningOnPlay = function(that, arg){\n        var panning = arg && arg.panning; // can be zero provided as argument\n        if (typeof panning === 'undefined') { panning = that.panning.location; }\n\n        if (typeof panning  === 'number') {\n            that.panning.node = context.createStereoPanner();\n            that.panning.node.pan.value = panning;\n            that.panning.type = 'stereo';\n        }\n        else {\n            that.panning.node = context.createPanner();\n            that.panning.node.setPosition(panning[0], panning[1], panning[2]);\n            that.panning.node.panningModel = arg.panningModel || that.panningModel || 'equalpower';\n            that.panning.type = '3d';\n        }\n\n        that.nodes.push(that.panning.node);\n\n    };\n///////////////////////////////////////////////////////////\n\n\n/** Initialize and configure a vibrato LFO Wad for playback **/\n    var setUpVibratoOnPlay = function(that, arg){\n        that.vibrato.wad = new Wad({\n            source : that.vibrato.shape,\n            pitch  : that.vibrato.speed,\n            volume : that.vibrato.magnitude,\n            env    : {\n                attack : that.vibrato.attack\n            },\n            destination : that.soundSource.frequency\n        });\n        that.vibrato.wad.play();\n    };\n///////////////////////////////////////////////////////////////\n\n\n/** Initialize and configure a tremolo LFO Wad for playback **/\n    var setUpTremoloOnPlay = function(that, arg){\n        that.tremolo.wad = new Wad({\n            source : that.tremolo.shape,\n            pitch  : that.tremolo.speed,\n            volume : that.tremolo.magnitude,\n            env    : {\n                attack : that.tremolo.attack,\n                hold   : 10\n            },\n            destination : that.gain[0].gain\n        });\n        that.tremolo.wad.play();\n    };\n///////////////////////////////////////////////////////////////\n\n    var setUpDelayOnPlay = function(that, arg){\n        if ( that.delay ) {\n            if ( !arg.delay ) { arg.delay = {}; }\n            //create the nodes well use\n            var delayNode = { // the custom delay node\n                interface    : 'custom',\n                input        : context.createGain(),\n                output       : context.createGain(),\n                delayNode    : context.createDelay(that.delay.maxDelayTime), // the native delay node inside the custom delay node.\n                feedbackNode : context.createGain(),\n                wetNode      : context.createGain(),\n            }\n\n            //set some decent values\n            delayNode.delayNode.delayTime.value = valueOrDefault(arg.delay.delayTime, that.delay.delayTime);\n            delayNode.feedbackNode.gain.value   = valueOrDefault(arg.delay.feedback, that.delay.feedback);\n            delayNode.wetNode.gain.value        = valueOrDefault(arg.delay.wet, that.delay.wet);\n\n\n            //set up the routing\n            if(delayNode.input){\n                delayNode.input.connect(delayNode.delayNode);\n                delayNode.input.connect(delayNode.output);\n            }\n            if(delayNode.delayNode){\n                delayNode.delayNode.connect(delayNode.feedbackNode);\n                delayNode.delayNode.connect(delayNode.wetNode);\n            }\n            if(delayNode.feedbackNode)\n            delayNode.feedbackNode.connect(delayNode.delayNode);\n            if(delayNode.wetNode)\n            delayNode.wetNode.connect(delayNode.output);\n            that.delay.delayNode = delayNode;\n\n            that.nodes.push(delayNode)\n        }\n    };\n\n/** **/\n    var constructCompressor = function(that, arg){\n        that.compressor = context.createDynamicsCompressor();\n        that.compressor.attack.value    = valueOrDefault(arg.compressor.attack, that.compressor.attack.value);\n        that.compressor.knee.value      = valueOrDefault(arg.compressor.knee, that.compressor.knee.value);\n        that.compressor.ratio.value     = valueOrDefault(arg.compressor.ratio, that.compressor.ratio.value);\n        that.compressor.release.value   = valueOrDefault(arg.compressor.release, that.compressor.release.value);\n        that.compressor.threshold.value = valueOrDefault(arg.compressor.threshold, that.compressor.threshold.value);\n        that.nodes.push(that.compressor);\n    };\n    var setUpTunaOnPlay = function(that, arg){\n        if ( !( that.tuna || arg.tuna ) ) { return }\n        var tunaConfig = {}\n        if ( that.tuna ) {\n            for ( var key in that.tuna ) {\n                tunaConfig[key] = that.tuna[key]\n            }\n        }\n\n        // overwrite settings from `this` with settings from arg\n        if ( arg.tuna ) {\n            for ( var key in arg.tuna ) {\n                tunaConfig[key] = arg.tuna[key]\n            }\n        }\n        // console.log('tunaconfig: ', tunaConfig)\n        for ( var key in tunaConfig) {\n            // console.log(key)\n            var tunaEffect = new Wad.tuna[key](tunaConfig[key])\n            that.nodes.push(tunaEffect)\n        }\n        // console.log(that.nodes)\n    }\n///\n\n/** Method to allow users to setup external fx in the constructor **/\n    Wad.prototype.constructExternalFx = function(arg, context){\n        //override me in your own code\n    };\n\n\n//////////////////////////////////////////////////////////////////////////////\n\n/** To be overrided by the user **/\n    Wad.prototype.setUpExternalFxOnPlay = function(arg, context){\n        //user does what is necessary here, and then maybe does something like:\n        // this.nodes.push(externalFX)\n    };\n///////////////////////////////////////////////////////////////\n\n\n/** the play() method will create the various nodes that are required for this Wad to play,\nset properties on those nodes according to the constructor arguments and play() arguments,\nplug the nodes into each other with plugEmIn(),\nthen finally play the sound by calling playEnv() **/\n    Wad.prototype.play = function(arg){\n        arg = arg || { arg : null };\n        if ( this.playable < 1 ) {\n            this.playOnLoad    = true;\n            this.playOnLoadArg = arg;\n        }\n\n        else if ( this.source === 'mic' ) {\n            if ( Wad.micConsent ) {\n                if ( arg.arg === null ) {\n                    plugEmIn(this, arg);\n                }\n                else {\n                    constructFilter(this, arg);\n                    constructVibrato(this, arg);\n                    constructTremolo(this, arg);\n                    constructReverb(this, arg);\n                    this.constructExternalFx(arg, context);\n                    constructPanning(this, arg);\n                    constructDelay(this, arg);\n                    setUpMic(this, arg);\n                    plugEmIn(this, arg);\n                }\n            }\n            else { \n                console.log('You have not given your browser permission to use your microphone.')\n                getConsent(this, arg).then(function (that) {\n                    that.play(arg);\n                });\n            }\n        }\n\n        else {\n            this.nodes = [];\n            if ( !arg.wait ) { arg.wait = 0; }\n            if ( arg.volume ) { this.volume = arg.volume; }\n            else { this.volume = this.defaultVolume; }\n            arg.offset = arg.offset || this.offset || 0;\n            if ( this.source in { 'sine' : 0, 'sawtooth' : 0, 'square' : 0, 'triangle' : 0 } ) {\n                setUpOscillator(this, arg);\n            }\n\n            else {\n                this.soundSource = context.createBufferSource();\n                this.soundSource.buffer = this.decodedBuffer;\n                if ( this.source === 'noise' || this.loop || arg.loop ) {\n                    this.soundSource.loop = true;\n                }\n            }\n\n            if ( this.soundSource.playbackRate ) {\n                this.soundSource.playbackRate.value = arg.rate || this.rate;\n            }\n\n            if ( this.soundSource.detune ) {\n                this.soundSource.detune.value = arg.detune || this.detune;\n            }\n\n            if (arg.exactTime === undefined) {\n                arg.exactTime = context.currentTime + arg.wait;\n            }\n\n            this.nodes.push(this.soundSource);\n\n\n    /**  sets the volume envelope based on the play() arguments if present,\n    or defaults to the constructor arguments if the volume envelope is not set on play() **/\n            setUpEnvOnPlay(this, arg);\n    ////////////////////////////////////////////////////////////////////////////////////////\n\n\n    /**  sets up the filter and filter envelope based on the play() argument if present,\n    or defaults to the constructor argument if the filter and filter envelope are not set on play() **/\n            setUpFilterOnPlay(this, arg);\n    ///////////////////////////////////////////////////////////////////////////////////////////////////\n            setUpTunaOnPlay(this, arg);\n\n            this.setUpExternalFxOnPlay(arg, context);\n\n\n            this.gain.unshift(context.createGain()); // sets up the gain node\n            this.gain[0].label = arg.label;\n            this.nodes.push(this.gain[0]);\n\n            if ( this.gain.length > 15 ) {\n                this.gain.length = 15\n            }\n\n            // sets up reverb\n            if ( this.reverb ) { setUpReverbOnPlay(this, arg); }\n\n    /**  sets panning based on the play() argument if present, or defaults to the constructor argument if panning is not set on play **/\n            setUpPanningOnPlay(this, arg);\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n            setUpDelayOnPlay(this, arg);\n\n            plugEmIn(this, arg);\n\n            if ( this.filter && this.filter[0].env ) { filterEnv(this, arg); }\n            playEnv(this, arg);\n\n            //sets up vibrato LFO\n            if ( this.vibrato ) { setUpVibratoOnPlay(this, arg); }\n\n            //sets up tremolo LFO\n            if ( this.tremolo ) { setUpTremoloOnPlay(this, arg); }\n        }\n        if ( arg.callback ) { arg.callback(this); }\n        return this;\n    };\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n\n    /** Change the volume of a Wad at any time, including during playback **/\n    Wad.prototype.setVolume = function(volume){\n        this.defaultVolume = volume;\n        if ( this.gain.length > 0 ) { this.gain[0].gain.value = volume; }\n        return this;\n    };\n\n    /**\n    Change the playback rate of a Wad during playback.\n    inputSpeed is a value of 0 < speed, and is the rate of playback of the audio.\n    E.g. if input speed = 2.0, the playback will be twice as fast\n    **/\n    Wad.prototype.setRate = function(inputSpeed) {\n\n        //Check/Save the input\n        var speed;\n        if(inputSpeed && inputSpeed > 0) speed = inputSpeed;\n        else speed = 0;\n\n        //Check if we have a soundsource (Though we always should)\n        if(this.soundSource) {\n\n            //Set the value\n            this.soundSource.playbackRate.value = speed;\n        }\n        else {\n\n            //Inform that there is no delay on the current wad\n            console.log(\"Sorry, but the wad does not contain a soundSource!\");\n        }\n\n        return this;\n    };\n\n    Wad.prototype.setPitch = function(pitch){\n        if ( pitch in Wad.pitches ) {\n          this.soundSource.frequency.value = Wad.pitches[pitch];\n        }\n        else {\n          this.soundSource.frequency.value = pitch;\n        }\n        return this;\n    };\n\n    Wad.prototype.setDetune = function(detune, timeConstant){\n        timeConstant = timeConstant || .01\n        this.soundSource.detune.setTargetAtTime(detune, context.currentTime, timeConstant)\n        return this;\n    };\n\n    /** Change the panning of a Wad at any time, including during playback **/\n    Wad.prototype.setPanning = function(panning, timeConstant){\n        timeConstant = timeConstant || .01\n        this.panning.location = panning;\n        if ( isArray(panning) && this.panning.type === '3d' && this.panning.node ) {\n            this.panning.node.setPosition(panning[0], panning[1], panning[2]);\n\n        }\n        else if ( typeof panning === 'number' && this.panning.type === 'stereo' && this.panning.node) {\n            this.panning.node.pan.setTargetAtTime(panning, context.currentTime, timeConstant)\n        }\n\n        if ( isArray(panning) ) { this.panning.type = '3d' }\n        else if ( typeof panning === 'number' ) { this.panning.type = 'stereo' }\n        return this;\n    };\n\n    /**\n    Change the Reverb of a Wad at any time, including during playback.\n    inputWet is a value of 0 < wetness/gain < 1\n    **/\n    Wad.prototype.setReverb = function(inputWet) {\n\n        //Check/Save the input\n\n        var wet;\n        if(inputWet && inputWet > 0 && inputWet < 1) wet = inputWet;\n        else if(inputWet >= 1) wet = 1;\n        else wet = 0;\n\n        //Check if we have delay\n        if(this.reverb) {\n\n            //Set the value\n            this.reverb.wet = wet;\n\n            //Set the node's value, if it exists\n            if(this.reverb.node) {\n\n                this.reverb.node.wet.gain.value = wet;\n            }\n        }\n        else {\n\n            //Inform that there is no reverb on the current wad\n            console.log(\"Sorry, but the wad does not contain Reverb!\");\n        }\n\n        return this;\n    };\n\n\n    /**\n    Change the Delay of a Wad at any time, including during playback.\n    inputTime is a value of time > 0, and is the time in seconds between each delayed playback.\n    inputWet is a value of gain 0 < inputWet < 1, and is Relative volume change between the original sound and the first delayed playback.\n    inputFeedback is a value of gain 0 < inputFeedback < 1, and is Relative volume change between each delayed playback and the next.\n    **/\n    Wad.prototype.setDelay = function(inputTime, inputWet, inputFeedback){\n\n        //Check/Save the input\n        var time;\n        if(inputTime && inputTime > 0) time = inputTime;\n        else time = 0;\n\n        var wet;\n        if(inputWet && inputWet > 0 && inputWet < 1) wet = inputWet;\n        else if(inputWet >= 1) wet = 1;\n        else wet = 0;\n\n        var feedback;\n        if(inputFeedback && inputFeedback > 0 && inputFeedback < 1) feedback = inputFeedback;\n        else if(inputFeedback >= 1) feedback = 1;\n        else feedback = 0;\n\n        //Check if we have delay\n        if(this.delay) {\n\n            //Set the value\n            this.delay.delayTime = time;\n            this.delay.wet = wet;\n            this.delay.feedback = feedback;\n\n            //Set the node's value, if it exists\n            if(this.delay.delayNode) {\n\n                this.delay.delayNode.delayNode.delayTime.value = time;\n                this.delay.delayNode.wetNode.gain.value = wet;\n                this.delay.delayNode.feedbackNode.gain.value = feedback;\n            }\n        }\n        else {\n\n            //Inform that there is no delay on the current wad\n            console.log(\"Sorry, but the wad does not contain delay!\");\n        }\n\n        return this;\n    };\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\n\n/** If multiple instances of a sound are playing simultaneously, stop() only can stop the most recent one **/\n    Wad.prototype.stop = function(label){\n        if ( !( this.source === 'mic' ) ) {\n            if ( label ) {\n                for ( var i = 0; i < this.gain.length; i++ ) {\n                    if ( this.gain[i].label === label ) {\n                        this.gain[i].gain.cancelScheduledValues(context.currentTime);\n                        this.gain[i].gain.setValueAtTime(this.gain[i].gain.value, context.currentTime);\n                        this.gain[i].gain.linearRampToValueAtTime(.0001, context.currentTime + this.env.release);\n                    }\n                }\n            }\n            if ( !label ) {\n                this.gain[0].gain.cancelScheduledValues(context.currentTime);\n                this.gain[0].gain.setValueAtTime(this.gain[0].gain.value, context.currentTime);\n                this.gain[0].gain.linearRampToValueAtTime(.0001, context.currentTime + this.env.release);\n            }\n        }\n        else if (Wad.micConsent ) {\n            this.mediaStreamSource.disconnect(0);\n        }\n        else { console.log('You have not given your browser permission to use your microphone.')}\n        if ( this.tremolo ) {\n            this.tremolo.wad.stop()\n        }\n    };\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n    var buflen = 2048;\n    var buf = new Uint8Array( buflen );\n    var MINVAL = 134;  // 128 == zero.  MINVAL is the \"minimum detected signal\" level.\n\n    var noteFromPitch = function( frequency ) {\n        var noteNum = 12 * (Math.log( frequency / 440 )/Math.log(2) );\n        return Math.round( noteNum ) + 69;\n    }\n\n    var frequencyFromNoteNumber = function( note ) {\n        return 440 * Math.pow(2,(note-69)/12);\n    }\n\n    var centsOffFromPitch = function( frequency, note ) {\n        return Math.floor( 1200 * Math.log( frequency / frequencyFromNoteNumber( note ))/Math.log(2) );\n    }\n\n\n    function autoCorrelate( buf, sampleRate ) {\n        var MIN_SAMPLES = 4;    // corresponds to an 11kHz signal\n        var MAX_SAMPLES = 1000; // corresponds to a 44Hz signal\n        var SIZE = 1000;\n        var best_offset = -1;\n        var best_correlation = 0;\n        var rms = 0;\n        var foundGoodCorrelation = false;\n\n        if (buf.length < (SIZE + MAX_SAMPLES - MIN_SAMPLES))\n            return -1;  // Not enough data\n\n        for ( var i = 0; i < SIZE; i++ ) {\n            var val = ( buf[i] - 128 ) / 128;\n            rms += val * val;\n        }\n        rms = Math.sqrt(rms/SIZE);\n        if (rms<0.01)\n            return -1;\n\n        var lastCorrelation=1;\n        for (var offset = MIN_SAMPLES; offset <= MAX_SAMPLES; offset++) {\n            var correlation = 0;\n\n            for (var i=0; i<SIZE; i++) {\n                correlation += Math.abs(((buf[i] - 128)/128)-((buf[i+offset] - 128)/128));\n            }\n            correlation = 1 - (correlation/SIZE);\n            if ((correlation>0.9) && (correlation > lastCorrelation))\n                foundGoodCorrelation = true;\n            else if (foundGoodCorrelation) {\n                // short-circuit - we found a good correlation, then a bad one, so we'd just be seeing copies from here.\n                return sampleRate/best_offset;\n            }\n            lastCorrelation = correlation;\n            if (correlation > best_correlation) {\n                best_correlation = correlation;\n                best_offset = offset;\n            }\n        }\n        if (best_correlation > 0.01) {\n            // console.log(\"f = \" + sampleRate/best_offset + \"Hz (rms: \" + rms + \" confidence: \" + best_correlation + \")\")\n            return sampleRate/best_offset;\n        }\n        return -1;\n    //  var best_frequency = sampleRate/best_offset;\n    }\n\n\n    Wad.Poly = function(arg){\n        if ( !arg ) { arg = {}; }\n        this.isSetUp  = false;\n        this.playable = 1;\n\n        if ( arg.reverb ) {\n            constructReverb(this, arg); // We need to make sure we have downloaded the impulse response before continuing with the setup.\n        }\n        else {\n            this.setUp(arg);\n        }\n    };\n\n    Wad.Poly.prototype.setUp = function(arg){ // Anything that needs to happen before reverb is set up can go here.\n        this.wads              = [];\n        this.input             = context.createAnalyser();\n        this.input.fftSize     = 2048\n        this.nodes             = [this.input];\n        this.destination       = arg.destination || context.destination; // the last node the sound is routed to\n        this.volume            = arg.volume || 1;\n        this.output            = context.createGain();\n        this.output.gain.value = this.volume;\n        this.tuna              = arg.tuna || null;\n\n        this.globalReverb = arg.globalReverb || false; // deprecated\n\n        constructFilter(this, arg);\n        if ( this.filter ) { createFilters(this, arg); }\n\n        if ( this.reverb ) { setUpReverbOnPlay(this, arg); }\n\n        this.constructExternalFx(arg, context);\n\n        constructPanning(this, arg);\n        setUpPanningOnPlay(this, arg);\n        if ( arg.compressor ) { constructCompressor(this, arg); }\n\n        constructDelay(this, arg);\n        setUpDelayOnPlay(this, arg);\n        setUpTunaOnPlay(this, arg);\n        this.nodes.push(this.output);\n        plugEmIn(this, arg);\n        this.isSetUp = true;\n        if ( arg.callback ) { arg.callback(this); }\n    }\n\n/**\n    The MIT License (MIT)\n\nCopyright (c) 2014 Chris Wilson\n**/\n    Wad.Poly.prototype.updatePitch = function( time ) {\n        this.input.getByteTimeDomainData( buf );\n        var ac = autoCorrelate( buf, context.sampleRate );\n\n        if ( ac !== -1 && ac !== 11025 && ac !== 12000 ) {\n            var pitch = ac;\n            this.pitch = Math.floor( pitch ) ;\n            var note = noteFromPitch( pitch );\n            this.noteName = Wad.pitchesArray[note - 12];\n            // Detune doesn't seem to work.\n            // var detune = centsOffFromPitch( pitch, note );\n            // if (detune == 0 ) {\n            //     this.detuneEstimate = 0;\n            // } else {\n\n            //     this.detuneEstimate = detune\n            // }\n        }\n        var that = this;\n        that.rafID = window.requestAnimationFrame( function(){ that.updatePitch() } );\n    }\n\n    Wad.Poly.prototype.stopUpdatingPitch = function(){\n        cancelAnimationFrame(this.rafID)\n    }\n\n    Wad.Poly.prototype.setVolume = function(volume){\n        if ( this.isSetUp ) {\n            this.output.gain.value = volume;\n        }\n        else {\n            console.log('This PolyWad is not set up yet.');\n        }\n        return this;\n    }\n\n    Wad.Poly.prototype.play = function(arg){\n        if ( this.isSetUp ) {\n            if ( this.playable < 1 ) {\n                this.playOnLoad    = true;\n                this.playOnLoadArg = arg;\n            }\n            else {\n                if ( arg && arg.volume ) {\n                    this.output.gain.value = arg.volume; // if two notes are played with volume set as a play arg, does the second one overwrite the first? maybe input should be an array of gain nodes, like regular wads.\n                    arg.volume = undefined; // if volume is set, it should change the gain on the polywad's gain node, NOT the gain nodes for individual wads inside the polywad.\n                }\n                for ( var i = 0; i < this.wads.length; i++ ) {\n                    this.wads[i].play(arg);\n                }\n            }\n        }\n        else {\n            console.log('This PolyWad is not set up yet.');\n        }\n        return this;\n    };\n\n    Wad.Poly.prototype.stop = function(arg){\n        if ( this.isSetUp ) {\n            for ( var i = 0; i < this.wads.length; i++ ) {\n                this.wads[i].stop(arg);\n            }\n        }\n    };\n\n    Wad.Poly.prototype.add = function(wad){\n        if ( this.isSetUp ) {\n            wad.destination = this.input;\n            this.wads.push(wad);\n            if ( wad instanceof Wad.Poly ) {\n                wad.output.disconnect(0);\n                if(wad.output)\n                wad.output.connect(this.input);\n            }\n        }\n        else {\n            console.log('This PolyWad is not set up yet.');\n        }\n        return this;\n    };\n\n\n\n    Wad.Poly.prototype.remove = function(wad){\n        if ( this.isSetUp ) {\n            for ( var i = 0; i < this.wads.length; i++ ) {\n                if ( this.wads[i] === wad ) {\n                    this.wads[i].destination = context.destination;\n                    this.wads.splice(i,1);\n                    if ( wad instanceof Wad.Poly ) {\n                        wad.output.disconnect(0);\n                        if(wad.output)\n                        wad.output.connect(context.destination);\n                    }\n                }\n            }\n        }\n        return this;\n    };\n\n    Wad.Poly.prototype.constructExternalFx = function(arg, context){\n\n    };\n\n/** If a Wad is created with reverb without specifying a URL for the impulse response,\ngrab it from the defaultImpulse URL **/\n    Wad.defaultImpulse = 'https://www.codecur.io/audio/widehall.wav';\n\n    // This method is deprecated.\n    Wad.setGlobalReverb = function(arg){\n        Wad.reverb                 = {};\n        Wad.reverb.node            = context.createConvolver();\n        Wad.reverb.gain            = context.createGain();\n        Wad.reverb.gain.gain.value = arg.wet;\n        var impulseURL             = arg.impulse || Wad.defaultImpulse;\n        var request                = new XMLHttpRequest();\n        request.open(\"GET\", impulseURL, true);\n        request.responseType = \"arraybuffer\";\n\n        request.onload = function() {\n            context.decodeAudioData(request.response, function (decodedBuffer){\n                Wad.reverb.node.buffer = decodedBuffer;\n            });\n        };\n        request.send();\n\n    };\n//////////////////////////////////////////////////////////////////////////////////////\n//  Utility function to avoid javascript type conversion bug checking zero values   //\n\n    var valueOrDefault = function(value, def) {\n        var val = (value == null) ? def : value;\n        return val;\n    };\n\n//////////////////////////////////////////////////////////////////////////////////////\n/** This object is a mapping of note names to frequencies. **/\n    Wad.pitches = {\n        'A0'  : 27.5000,\n        'A#0' : 29.1352,\n        'Bb0' : 29.1352,\n        'B0'  : 30.8677,\n        'B#0'  : 32.7032,\n        'Cb1'  : 30.8677,\n        'C1'  : 32.7032,\n        'C#1' : 34.6478,\n        'Db1' : 34.6478,\n        'D1'  : 36.7081,\n        'D#1' : 38.8909,\n        'Eb1' : 38.8909,\n        'E1'  : 41.2034,\n        'Fb1'  : 41.2034,\n        'E#1'  : 43.6535,\n        'F1'  : 43.6535,\n        'F#1' : 46.2493,\n        'Gb1' : 46.2493,\n        'G1'  : 48.9994,\n        'G#1' : 51.9131,\n        'Ab1' : 51.9131,\n        'A1'  : 55.0000,\n        'A#1' : 58.2705,\n        'Bb1' : 58.2705,\n        'B1'  : 61.7354,\n        'Cb2'  : 61.7354,\n        'B#1'  : 65.4064,\n        'C2'  : 65.4064,\n        'C#2' : 69.2957,\n        'Db2' : 69.2957,\n        'D2'  : 73.4162,\n        'D#2' : 77.7817,\n        'Eb2' : 77.7817,\n        'E2'  : 82.4069,\n        'Fb2'  : 82.4069,\n        'E#2'  : 87.3071,\n        'F2'  : 87.3071,\n        'F#2' : 92.4986,\n        'Gb2' : 92.4986,\n        'G2'  : 97.9989,\n        'G#2' : 103.826,\n        'Ab2' : 103.826,\n        'A2'  : 110.000,\n        'A#2' : 116.541,\n        'Bb2' : 116.541,\n        'B2'  : 123.471,\n        'Cb3'  : 123.471,\n        'B#2'  : 130.813,\n        'C3'  : 130.813,\n        'C#3' : 138.591,\n        'Db3' : 138.591,\n        'D3'  : 146.832,\n        'D#3' : 155.563,\n        'Eb3' : 155.563,\n        'E3'  : 164.814,\n        'Fb3'  : 164.814,\n        'E#3'  : 174.614,\n        'F3'  : 174.614,\n        'F#3' : 184.997,\n        'Gb3' : 184.997,\n        'G3'  : 195.998,\n        'G#3' : 207.652,\n        'Ab3' : 207.652,\n        'A3'  : 220.000,\n        'A#3' : 233.082,\n        'Bb3' : 233.082,\n        'B3'  : 246.942,\n        'Cb4'  : 246.942,\n        'B#3'  : 261.626,\n        'C4'  : 261.626,\n        'C#4' : 277.183,\n        'Db4' : 277.183,\n        'D4'  : 293.665,\n        'D#4' : 311.127,\n        'Eb4' : 311.127,\n        'E4'  : 329.628,\n        'Fb4'  : 329.628,\n        'E#4'  : 349.228,\n        'F4'  : 349.228,\n        'F#4' : 369.994,\n        'Gb4' : 369.994,\n        'G4'  : 391.995,\n        'G#4' : 415.305,\n        'Ab4' : 415.305,\n        'A4'  : 440.000,\n        'A#4' : 466.164,\n        'Bb4' : 466.164,\n        'B4'  : 493.883,\n        'Cb5'  : 493.883,\n        'B#4'  : 523.251,\n        'C5'  : 523.251,\n        'C#5' : 554.365,\n        'Db5' : 554.365,\n        'D5'  : 587.330,\n        'D#5' : 622.254,\n        'Eb5' : 622.254,\n        'E5'  : 659.255,\n        'Fb5'  : 659.255,\n        'E#5'  : 698.456,\n        'F5'  : 698.456,\n        'F#5' : 739.989,\n        'Gb5' : 739.989,\n        'G5'  : 783.991,\n        'G#5' : 830.609,\n        'Ab5' : 830.609,\n        'A5'  : 880.000,\n        'A#5' : 932.328,\n        'Bb5' : 932.328,\n        'B5'  : 987.767,\n        'Cb6'  : 987.767,\n        'B#5'  : 1046.50,\n        'C6'  : 1046.50,\n        'C#6' : 1108.73,\n        'Db6' : 1108.73,\n        'D6'  : 1174.66,\n        'D#6' : 1244.51,\n        'Eb6' : 1244.51,\n        'Fb6'  : 1318.51,\n        'E6'  : 1318.51,\n        'E#6'  : 1396.91,\n        'F6'  : 1396.91,\n        'F#6' : 1479.98,\n        'Gb6' : 1479.98,\n        'G6'  : 1567.98,\n        'G#6' : 1661.22,\n        'Ab6' : 1661.22,\n        'A6'  : 1760.00,\n        'A#6' : 1864.66,\n        'Bb6' : 1864.66,\n        'B6'  : 1975.53,\n        'Cb7'  : 1975.53,\n        'B#6'  : 2093.00,\n        'C7'  : 2093.00,\n        'C#7' : 2217.46,\n        'Db7' : 2217.46,\n        'D7'  : 2349.32,\n        'D#7' : 2489.02,\n        'Eb7' : 2489.02,\n        'E7'  : 2637.02,\n        'Fb7'  : 2637.02,\n        'E#7'  : 2793.83,\n        'F7'  : 2793.83,\n        'F#7' : 2959.96,\n        'Gb7' : 2959.96,\n        'G7'  : 3135.96,\n        'G#7' : 3322.44,\n        'Ab7' : 3322.44,\n        'A7'  : 3520.00,\n        'A#7' : 3729.31,\n        'Bb7' : 3729.31,\n        'B7'  : 3951.07,\n        'Cb8' : 3951.07,\n        'B#7'  : 4186.01,\n        'C8'  : 4186.01\n    };\n\n\n    Wad.pitchesArray = [ // Just an array of note names. This can be useful for mapping MIDI data to notes.\n        'C0',\n        'C#0',\n        'D0',\n        'D#0',\n        'E0',\n        'F0',\n        'F#0',\n        'G0',\n        'G#0',\n        'A0',\n        'A#0',\n        'B0',\n        'C1',\n        'C#1',\n        'D1',\n        'D#1',\n        'E1',\n        'F1',\n        'F#1',\n        'G1',\n        'G#1',\n        'A1',\n        'A#1',\n        'B1',\n        'C2',\n        'C#2',\n        'D2',\n        'D#2',\n        'E2',\n        'F2',\n        'F#2',\n        'G2',\n        'G#2',\n        'A2',\n        'A#2',\n        'B2',\n        'C3',\n        'C#3',\n        'D3',\n        'D#3',\n        'E3',\n        'F3',\n        'F#3',\n        'G3',\n        'G#3',\n        'A3',\n        'A#3',\n        'B3',\n        'C4',\n        'C#4',\n        'D4',\n        'D#4',\n        'E4',\n        'F4',\n        'F#4',\n        'G4',\n        'G#4',\n        'A4',\n        'A#4',\n        'B4',\n        'C5',\n        'C#5',\n        'D5',\n        'D#5',\n        'E5',\n        'F5',\n        'F#5',\n        'G5',\n        'G#5',\n        'A5',\n        'A#5',\n        'B5',\n        'C6',\n        'C#6',\n        'D6',\n        'D#6',\n        'E6',\n        'F6',\n        'F#6',\n        'G6',\n        'G#6',\n        'A6',\n        'A#6',\n        'B6',\n        'C7',\n        'C#7',\n        'D7',\n        'D#7',\n        'E7',\n        'F7',\n        'F#7',\n        'G7',\n        'G#7',\n        'A7',\n        'A#7',\n        'B7',\n        'C8'\n    ];\n//////////////////////////////////////////////////////////////\n    Wad.assignMidiMap = function(midiMap, which, success, failure){\n        var which = which || 0;\n        navigator.requestMIDIAccess().then(function(){\n            if ( Wad.midiInputs[which] ) {\n                Wad.midiInputs[which].onmidimessage = midiMap;\n                if  ( typeof success === 'function' ) { success() }\n            }\n            else if ( typeof failure === 'function' ) { failure() }\n\n        })\n\n    }\n    Wad.midiInstrument = {\n        play : function() { console.log('playing midi')  },\n        stop : function() { console.log('stopping midi') }\n    };\n    Wad.midiInputs  = [];\n\n    var midiMap = function(event){\n        console.log(event.receivedTime, event.data);\n        if ( event.data[0] === 144 ) { // 144 means the midi message has note data\n            // console.log('note')\n            if ( event.data[2] === 0 ) { // noteOn velocity of 0 means this is actually a noteOff message\n                console.log('|| stopping note: ', Wad.pitchesArray[event.data[1]-12]);\n                Wad.midiInstrument.stop(Wad.pitchesArray[event.data[1]-12]);\n            }\n            else if ( event.data[2] > 0 ) {\n                console.log('> playing note: ', Wad.pitchesArray[event.data[1]-12]);\n                Wad.midiInstrument.play({pitch : Wad.pitchesArray[event.data[1]-12], label : Wad.pitchesArray[event.data[1]-12], callback : function(that){\n                }})\n            }\n        }\n        else if ( event.data[0] === 176 ) { // 176 means the midi message has controller data\n            console.log('controller');\n            if ( event.data[1] == 46 ) {\n                if ( event.data[2] == 127 ) { Wad.midiInstrument.pedalMod = true; }\n                else if ( event.data[2] == 0 ) { Wad.midiInstrument.pedalMod = false; }\n            }\n        }\n        else if ( event.data[0] === 224 ) { // 224 means the midi message has pitch bend data\n            console.log('pitch bend');\n        }\n    };\n\n\n    var onSuccessCallback = function(midiAccess){\n        // console.log('inputs: ', m.inputs)\n\n        Wad.midiInputs = []\n        var val = midiAccess.inputs.values();\n        for ( var o = val.next(); !o.done; o = val.next() ) {\n            Wad.midiInputs.push(o.value)\n        }\n        // Wad.midiInputs = [m.inputs.values().next().value];   // inputs = array of MIDIPorts\n        console.log('MIDI inputs: ', Wad.midiInputs)\n        // var outputs = m.outputs(); // outputs = array of MIDIPorts\n        for ( var i = 0; i < Wad.midiInputs.length; i++ ) {\n            Wad.midiInputs[i].onmidimessage = midiMap; // onmidimessage( event ), event.data & event.receivedTime are populated\n        }\n        // var o = m.outputs()[0];           // grab first output device\n        // o.send( [ 0x90, 0x45, 0x7f ] );     // full velocity note on A4 on channel zero\n        // o.send( [ 0x80, 0x45, 0x7f ], window.performance.now() + 1000 );  // full velocity A4 note off in one second.\n    };\n    var onErrorCallback = function(err){\n        console.log(\"Failed to get MIDI access\", err);\n    };\n\n    if ( navigator && navigator.requestMIDIAccess ) {\n        try {\n            navigator.requestMIDIAccess().then(onSuccessCallback, onErrorCallback);\n        }\n        catch(err) {\n            console.log(\"Failed to get MIDI access\", err);\n        }\n    }\n\n\n    Wad.presets = {\n        hiHatClosed : { source : 'noise', env : { attack : .001, decay : .008, sustain : .2, hold : .03, release : .01}, filter : { type : 'highpass', frequency : 400, q : 1 } },\n        snare : { source : 'noise', env : {attack : .001, decay : .01, sustain : .2, hold : .03, release : .02}, filter : {type : 'bandpass', frequency : 300, q : .180 } },\n        hiHatOpen : { source : 'noise', env : { attack : .001, decay : .008, sustain : .2, hold : .43, release : .01}, filter : { type : 'highpass', frequency : 100, q : .2 } },\n        ghost : { source : 'square', volume : .3, env : { attack : .01, decay : .002, sustain : .5, hold : 2.5, release : .3 }, filter : { type : 'lowpass', frequency : 600, q : 7, env : { attack : .7, frequency : 1600 } }, vibrato : { attack : 8, speed : 8, magnitude : 100 } },\n        piano : { source : 'square', volume : 1.4, env : { attack : .01, decay : .005, sustain : .2, hold : .015, release : .3 }, filter : { type : 'lowpass', frequency : 1200, q : 8.5, env : { attack : .2, frequency : 600 } } }\n    };\n    return Wad;\n\n})()\n\nif(typeof module !== 'undefined' && module.exports) {\n    module.exports = Wad;\n}\n\nexport default Wad;\n\n"],"sourceRoot":""}